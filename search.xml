<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 后端必备知识]]></title>
    <url>%2F2019%2F08%2F28%2FJava-%E5%90%8E%E7%AB%AF%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Java 后端面试进阶Java基础，核心 基础知识 语法、流程 String、数组 数组初始化、二维数组 String字符串查找、字符串截取、字符串转字符数组 核心技术 接口、抽象类 继承，多态，封装 异常处理 集合框架（源码实现） List ArrayList LinkedList Set HashSet TreeSet Map HashMap TreeMap ConcurrentHashMap Queue ConcurrentLinkedQueue Stack Collection的synchronizedXXX写法 多线程 IO输入输出流 Java Web技术栈 SHH框架 Spring IOC AOP 常用注释 J2EE JSP+servlet Struts2 SpringMVC Spring Boot Spring MVC ORM框架 Hibernate Mybatis 将数据库的数据转化为Java对象 Shiro Netty 数据库 SQL语句 MySQL 引擎 InnoDB支持事务 MylSAM支持全文索引 SQL优化 分库分表 索引 主键索引 组合索引 explain 存储过程 SQL注入 使用#不使用$ 锁 表锁 行锁 乐观锁 悲观锁 事务隔离级别ACID 原子性 一致性 隔离性 持久性 Nosql 分布式缓存 Memocache Redis大数据 Hadoop Hbase Spark Storm/jStorm构建工具 Maven构建工具 管理jar包 pom.xml文件指定需要的jar包 功能 编译 打包 运行单元测试 项目构建工具 Gradle 服务器 Tomcat 应用服务器 web应用的运行环境 Nginx/Tengine（web应用服务器） Git、GitHub JavaWeb常用组件 日志系统 log4j 单元测试 Jnuit JSON HTTPClient 加密工具 压缩工具 Java进阶技术 网络编程 Socket 并发编程 Java多线程技术 JUC包里的并发类 线程池 参数设置 corePoolsize maximumpoolsize BlockingQueue《Runnable》 workqueue RejectedExceptionHandler handler 原理 拒绝策略 Handler CallerRunsPlocy 直接运行run方法，执行自身的run方法 AvortPolicy 抛出异常，丢弃任务 DiscardPlocy 直接丢弃 DiscarOldestPolicy 抛弃最老的线程，位于队列头的任务会被删除 并发工具类 阻塞队列 workqueue 直接提交 无界队列linked 各个任务相互独立 有界队列 防止资源耗尽 数据结构 ConcurrentHashMap CoincurrentLinkedQueue 并发工具 CountDownLatch Semaphore CyclicBarrier Exchanger JVM 类加载机制 内存模型 GC机制 回收算法 垃圾收集器 调优 工具 jstack jmap jconsole 设计模式 工厂模式 代理模式 门面模式 观察者模式 责任链模式 适配器模式 装饰者模式 单例模式 后端进阶技术 分布式 负载均衡 分支主题 分布式缓存 缓存 消息队列 kfaka 远程调用RPC RMI Thrift Dubbo（DubboX） 服务治理，也可作为微服务 gRPC Docker 进程级别的隔离机制 集群规模数万台 本身不是容器，而是创建容器的工具 搭建一次，到处可用 核心技术 镜像Image 容器Container 仓库Repository 基本组成 Docker Client 客户端 Docker Daemon 守护进程 Docker Images Docker镜像 Docker Registry 镜像的仓库 Docker Container Docker容器 Linux与项目部署 基本命令 Shell脚本 内核相关知识 中间件与系统拆分系统架构 系统设计，拆分系统，小模块 预估时间 考虑后期维护与升级 性能优化]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java 后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java String]]></title>
    <url>%2F2019%2F08%2F28%2FJava-String%2F</url>
    <content type="text"><![CDATA[StringString类创建 String s = new String(“abc”); char a[]={‘a’,’b’,’c’};String s = new String(a); char a[]={‘a’,’b’,’c’};String s =new String(a,2,4) 字符串连接+ 创建新的对象、增加内存开销 变化的string不推荐会用+操作 是不可变的对象 使用final 关键字修饰的字符数组 是线程安全的 字符串方法 获取长度 length() 定位字符串开始位置indexOf() 最后一个 lastIndexOF() 取字符 charAt(index) 获取（begin，end-1）的子字符串 substring(begin,end) 以某个字符开始 starsWith 以某个字符结束 endsWith 全部转为大写 toUpperCase 全部转为小写 toLowerCase 字符串内容相等 equals 字典序比较 compareTo 字符串分割(支持正则表达式) split() 字符串格式化 format(“xx%”,Object) 日期时间格式化 字符串替换 replace() 正则表达式 非[^456] 任意一个 [a~r] 任意字母[a-zA-Z] 或(并运算)[a-e[g-z]] 交运算[a-o&amp;&amp;[def]] 差运算[a-d&amp;&amp;[^bc]] 可变的String对象StringBuffer 可以更改，可以替代Sring类 一般生产环境中都用StringBuffer，确保线程安全 new StringBuffer(“chen”) 添加字符串 append(“robin”) 输出 chenrobin length() 长度 9 翻转 reverse 输出 nibornehc 插入 insert(4,”word”) 输出 niborWang setLength(3) nib delete(5,10) StringBuilder 不会增加内存开销 单线程，大量数据时，使用StringBuilder速度更快 append(“aa”) insert(5,”word”) delete(5,10) reverse() setLength() 区别 有公共的父类AbstractStringBuilder抽象类 StringBuilder并未对方法添加同步锁，线程不安全的 Stringbuffer添加了同步锁，或对调用的方法添加了同步锁，线程安全的 实现原理 提高字符串连接效率 采用一个char数组保存字符串,初始大小16 append动态扩容 每次固定扩容2倍，JNI方法System.arraycopy()]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java string</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基础知识]]></title>
    <url>%2F2019%2F08%2F28%2FJava-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Java基础知识语言基础基本数据类型 boolean 包装类Boolean 数值类型 整型 byte 8位 short 16位 包装类Short int 32位 包装类Integer long 64位 包装类Long 字符 char 16位 包装类Character 浮点型 float 32位 包装类Float double 64位 包装类Double 主类结构 包 成员变量和局部变量 主方法 API类库 类型转换 自动类型转换 数值范围由小向大 表达式自动提升类型 强制类型转换 int b =10; int a = (short)b; 变量与常量运算符 三元运算符 表达式？true：false 位运算符 按位与&amp; 按 位或| 按位取反~ 按位异或^ 移位操作 左移&lt;&lt; 右移&gt;&gt; 无符号右移&gt;&gt;&gt; 自增++、自减– 逻辑运算 与&amp;&amp; 或|| 非! 代码注释及编码规范 // / / /* / 引用数据类型 类object 接口类型 数组类型 null类型 枚举类型 标注类型 数组 数组创建 声明的同时分配内存 int[] month = new int[12] int[][] arr = new int[2][4] 先声明后分配内存 int[] arr int[][] arr int arr[] int arr[][] arr = new int[5] 不使用new 则不会分配内存 arr = new int[2][4] arr = new int[2][] 分别分配 arr[0] = new int[2]; arr[1] = new int[4] 初始化 int arr[] = new int[]{1,2,3,4,5} int arr[] = {1,2,3,4,5} int arr[][] = {/{1,2,3},{4,5,6}/} String 不可变类，线程安全，final修饰 ==与equals new String(“abc”) 生成了几个对象 字符串常量池 连接操作+ 实现原理 类与对象 OOP面向对象编程 封装、继承、多态 只能单继承，可以实现多个接口 抽象类与接口 包装类 拆箱：将对象拆箱为基本类型 装箱：将基本类型封装为对象 数字处理Math类 数字格式化 小数形式0.001~10 000 000 科学计数法E’ DecimalFormat 数学运算方法 三角函数 指数函数 对数函数 平方根 随机数 math.random方法 (int)m+(int)(math.random()*n)产生m~m+n (char)a+(char)(math.random()*（b-a+1)产生a~b Random类 随机数种子 Random r = new Random(); 大数字运算 BigInteger大整数 基本数学运算 位运算 去相反数 绝对值 最大公约数 是否是素数 BigDecimal大小数 流程控制foreach]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 核心知识]]></title>
    <url>%2F2019%2F08%2F28%2FJava-%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Java核心多线程 并发、多线程机制：程序同时完成多件事情 Thread类继承方式使用 Runnable接口使用 线程的生命周期 出生 创建new Thread(） 就绪 t.start() 运行 等待 休眠 阻塞 死亡 线程同步 线程安全 HashMap线程不安全 异步的 currentHashmap可解决 HashTable线程安全 同步的 线程同步机制 同步块 synchronized(object){ //访问资源的代码块} 同步方法 在方法前加上修饰synchronized void 份（）{//访问资源的代码} 网络编程 应用层 TCP/IP协议 传输层 互联网层 网络层 TCP、UDP协议 TCP固接连接为基础 socket类编程 inteAddress类 ServerSocket类 服务器套接字，等待来自网络上的请求 聊天室 UDP无连接的通信协议 发送端 DatagramSocket创建套接字 DatagramPacket创建数据包 send 接收端 DatagramSocket创建套接字，接收端口 DatagramPacket创建字节组，接收数据包 receive 不断广播，同组的主机可随时接收数据包 224.0.0.0~224.255.255.255 端口、套接字 端口 提供多种服务 套接字Socket 将应用程序与端口连接起来 集合类 Collection List集合 ArrayList 异步的 动态数组 LinkedList 方法 get set Set集合 HashSet TreeSet 元素不可重复 方法 添加 add 删除 remove 查找 遍历 迭代器iterator() Map集合 Hashmap 效率更高 hash表实现 异步的，线程不安全 可接受空值null TreeMap 存在映射顺序 Map中的key对象有一定顺序 顺序输出时转换为Treemap 方法 put（key，value）添加 是否包含containsKey(key) get(key)返回指定可以的内容 keyset返回所有key的set集合 values值对象的collection集合 Dictionary类 HashTable 同步的，保证线程安全 不能为空值 Vector类 动态数组 同步的，线程安全的 单独的方法操作上是安全的 方法都使用了synchronized修饰 序列化 底层实现与ArrayList类似 JVM相关 内存分配 堆-分配对象 栈-线程的工作空间 方法区-静态方法，变量，常量池 操作计数器 垃圾回收机制 异常处理 异常类 当某个方法出现异常会创建一个异常对象 处理异常 当前方法中处理 向上抛出异常 捕捉异常 try{}catch(Exceptiontype e){} try中有异常，则后面的不会执行 catch后面的继续执行 自定义异常 throw抛出异常 throws抛出的错误信息 运行时异常 Throwable类的子类 常见异常 类型转换异常 未找到相应类异常‘’ 算数异常 数组下标越界异常 数组包含不兼容的值 操作数据库异常 空指针异常 字段未找到、方法未找到 字符串转数字异常 数组元素个数为负数异常 字符串索引异常 IO异常 不允许访问某类异常 newInstance创建实例，但类不允许实例化 文件已结束、文件未找到异常 枚举类型与泛型 枚举类型 将常量封装在类中或接口中，编译时检查 常量放在枚举类型中enum 优点 类型安全 紧凑有效的数据定义 可以和程序其他部分完美交互 运行效率高 泛型 解决类型安全问题，提供编译时安全检查 总结 泛型的参数必须是类类型，不可以是简单类型 参数可有多个 可使用extends限制泛型的类型 可使用通配符限定泛型的类型 输入输出 字节输入输出流 InputStream 字节输入流 Reader类 FileReader OutputStream Writer类 FileWriter 文件输入输出流 File类 获取文件基本信息 FileInputStream文件输入 FileoutputStream文件输出 缓存区输入输出 BufferedInputStream BufferedReader BufferedOutputStream BufferedWriter 缓存是IO的性能优化 数据输入输出流 DataInputStream DataOutputStream 不必关心数据类型 ZIP压缩输入输出流 ZipEntry类 ZipInpuStream ZipOutputStream 数据库操作 JDBC java.sql connection接口 Statement接口 preparedstatement drivermanager resultset 特点 安全性控制 并发控制 完整性控制 故障的发现和恢复 SQL语言 数据定义 create、alter 数据操纵 select、insert、 数据控制 grant、revoke 事务控制 commit、rollback]]></content>
      <categories>
        <category>java学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java核心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 必备知识]]></title>
    <url>%2F2019%2F08%2F28%2FJava-%E5%BF%85%E5%A4%87%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Java必备知识JVM相关 内存模型与结构 垃圾回收原理，性能调优 class二进制字节码结构 class loader体系 class加载过程 实例创建过程 方法执行过程 Java运行 带package的类如何运行 各个路径 classpath java library path java运行主目录 java多线程 多线程实现和启动 callable与runnable syncrhoized’与reentranLock 线程池 集合框架 HashMap与HashTable HashMap 异步的，线程不安全 HashTable 同步的，线程安全 ArrayList与Vector ArrayList 异步的，线程不安全 三种迭代方式 foreach(str:list) 数组遍历for(i;i&lt;;++i) 使用迭代器while(itera.hasnext()) Vector 同步的，线程安全，单独的方法使用synicalized 动态数组 Collection集合，元素集合 抽象类 List、Set 和 Queue 具体实现类 ArrayList、LinkedList、HashSet、LinkedHashSet 集合是一个对象，可容纳其他对象的引用 比较器 Map图，键/值对 HashMap、LinkedHashMap Map遍历方式 for (String key : map.keySet()) Map.entrySet使用iterator遍历key和value Map.entrySet遍历key和value Map.values()遍历所有的value，但不能遍历keyjava.util其他类 Vector Stack 默认的扩容方式是原来的2倍 Dictionary Hashtable Properties 持久的属性集 BitSet 存储位值，数组随需要增加 Java序列化 一个对象可被表示为一个字节序列，包含对象的数据、有关对象的类型信息和存储在对象中的数据的类型 反序列化，JVM独立的 在任何平台上均可反序列化]]></content>
      <categories>
        <category>Java 学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F28%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 学习]]></title>
    <url>%2F2019%2F08%2F28%2FJava-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js学习]]></title>
    <url>%2F2019%2F05%2F13%2Fjs%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[js基础知识 js包括的内容 ES标准 （制定了js的基本语法{语句、运算符、表达式}，内置的对象{Array、String、Date、Math}）DOM （HTML、XML 能够操作DOM的不仅仅是js，还包括了JAVA、PHP、Python等语言）BOM （浏览器访问对象，包括了弹出框等）应用领域 （验证表单–&gt; 特效交互–&gt; 数据交互{Ajax}–&gt; 游戏开发{canvas}–&gt; 桌面应用、移动应用、小程序等） js基本语法 变量var 获取元素getElementById、querySelector(CSS3.0)、querySelectorAll(css3.0)、 console.log 事件onclick、onmouseover、onmouseout、事件里的 this ，指向触发事件的对象 123object.onclick = function()&#123; // 具体执行 &#125; this一般用在函数内部，指向事件的对象]]></content>
      <categories>
        <category>web前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket学习]]></title>
    <url>%2F2019%2F05%2F12%2Fwebsocket%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[First blog]]></title>
    <url>%2F2019%2F05%2F12%2FFirst-blog%2F</url>
    <content type="text"><![CDATA[写博客（新建） 使用hexo new “文章名” title: Java 学习 copyright: true date: 2019-08-28 15:50:11 categories: description: tags: 写内容：支持markdown语法（很好用），只需要定义格式，其余的自动布局 先清除 使用hexo clean 再进行编译 hexo generator 最后进行发布 上传到github博客上 hexo deploy 本地运行 hexo server 紧接着是文章的正文部分]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>其他</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveCocoa 进阶]]></title>
    <url>%2F2018%2F07%2F18%2FReactiveCocoa-%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[前言 在上篇文章中介绍了ReactiveCocoa的基础知识,接下来我们来深入介绍ReactiveCocoa及其在MVVM中的用法。 常见操作方法介绍操作须知所有的信号（RACSignal）都可以进行操作处理，因为所有操作方法都定义在RACStream.h中，因此只要继承RACStream就有了操作处理方法。 操作思想运用的是Hook（钩子）思想，Hook是一种用于改变API(应用程序编程接口：方法)执行结果的技术. Hook用处：截获API调用的技术。 有关Hook的知识可以看我的这篇博客《Objective-C Runtime 的一些基本使用》中的 更换代码的实现方法 一节, Hook原理：在每次调用一个API返回结果之前，先执行你自己的方法，改变结果的输出。 操作方法bind（绑定）- ReactiveCocoa核心方法ReactiveCocoa 操作的核心方法是 bind（绑定）,而且也是RAC中核心开发方式。之前的开发方式是赋值，而用RAC开发，应该把重心放在绑定，也就是可以在创建一个对象的时候，就绑定好以后想要做的事情，而不是等赋值之后在去做事情。 列如，把数据展示到控件上，之前都是重写控件的 setModel 方法，用RAC就可以在一开始创建控件的时候，就绑定好数据。 作用 RAC底层都是调用bind， 在开发中很少直接使用 bind 方法，bind属于RAC中的底层方法，我们只需要调用封装好的方法，bind用作了解即可. bind方法使用步骤 传入一个返回值 RACStreamBindBlock 的 block。 描述一个 RACStreamBindBlock 类型的 bindBlock作为block的返回值。 描述一个返回结果的信号，作为 bindBlock 的返回值。 注意：在bindBlock中做信号结果的处理。 bind方法参数 RACStreamBindBlock:typedef RACStream * (^RACStreamBindBlock)(id value, BOOL *stop); 参数一(value):表示接收到信号的原始值，还没做处理 参数二(*stop):用来控制绑定Block，如果*stop = yes,那么就会结束绑定。 返回值：信号，做好处理，在通过这个信号返回出去，一般使用 RACReturnSignal,需要手动导入头文件RACReturnSignal.h 使用 假设想监听文本框的内容，并且在每次输出结果的时候，都在文本框的内容拼接一段文字“输出：” 使用封装好的方法：在返回结果后，拼接。 123456[_textField.rac_textSignal subscribeNext:^(id x) &#123; // 在返回结果后，拼接 输出： NSLog(@&quot;输出:%@&quot;,x);&#125;]; 方式二:，使用RAC中 bind 方法做处理，在返回结果前，拼接。 这里需要手动导入#import &lt;ReactiveCocoa/RACReturnSignal.h&gt;，才能使用RACReturnSignal 12345678910111213141516171819[[_textField.rac_textSignal bind:^RACStreamBindBlock&#123; // 什么时候调用: // block作用:表示绑定了一个信号. return ^RACStream *(id value, BOOL *stop)&#123; // 什么时候调用block:当信号有新的值发出，就会来到这个block。 // block作用:做返回值的处理 // 做好处理，在返回结果前，拼接 输出: return [RACReturnSignal return:[NSString stringWithFormat:@&quot;输出:%@&quot;,value]]; &#125;;&#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; 底层实现 源信号调用bind,会重新创建一个绑定信号。 当绑定信号被订阅，就会调用绑定信号中的 didSubscribe ，生成一个 bindingBlock 。 当源信号有内容发出，就会把内容传递到 bindingBlock 处理，调用bindingBlock(value,stop) 调用bindingBlock(value,stop)，会返回一个内容处理完成的信号RACReturnSignal。 订阅RACReturnSignal，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。 注意:不同订阅者，保存不同的nextBlock，看源码的时候，一定要看清楚订阅者是哪个。 映射映射主要用这两个方法实现：flattenMap,Map,用于把源信号内容映射成新的内容。 flattenMap 作用 把源信号的内容映射成一个新的信号，信号可以是任意类型 使用步骤 传入一个block，block类型是返回值RACStream，参数value 参数value就是源信号的内容，拿到源信号的内容做处理 包装成RACReturnSignal信号，返回出去。 使用 监听文本框的内容改变，把结构重新映射成一个新值. 12345678910111213[[_textField.rac_textSignal flattenMap:^RACStream *(id value) &#123; // block调用时机：信号源发出的时候 // block作用：改变信号的内容 // 返回RACReturnSignal return [RACReturnSignal return:[NSString stringWithFormat:@&quot;信号内容：%@&quot;, value]]; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; 底层实现 flattenMap内部调用 bind 方法实现的,flattenMap中block的返回值，会作为bind中bindBlock的返回值。 当订阅绑定信号，就会生成 bindBlock。 当源信号发送内容，就会调用bindBlock(value, *stop) 调用bindBlock，内部就会调用 flattenMap 的 bloc k，flattenMap 的block作用：就是把处理好的数据包装成信号。 返回的信号最终会作为 bindBlock 中的返回信号，当做 bindBlock 的返回信号。 订阅 bindBlock 的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。 Map 作用 把源信号的值映射成一个新的值 使用步骤 传入一个block,类型是返回对象，参数是 value value就是源信号的内容，直接拿到源信号的内容做处理 把处理好的内容，直接返回就好了，不用包装成信号，返回的值，就是映射的值。 使用 监听文本框的内容改变，把结构重新映射成一个新值. 123456789[[_textField.rac_textSignal map:^id(id value) &#123; // 拼接完后，返回对象 return [NSString stringWithFormat:@&quot;信号内容: %@&quot;, value]; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; 底层实现: Map底层其实是调用 flatternMap,Map 中block中的返回的值会作为 flatternMap 中block中的值 当订阅绑定信号，就会生成 bindBlock 当源信号发送内容，就会调用 bindBlock(value, *stop) 调用 bindBlock ，内部就会调用 flattenMap的block flattenMap的block 内部会调用 Map 中的block，把 Map 中的block返回的内容包装成返回的信号 返回的信号最终会作为 bindBlock 中的返回信号，当做 bindBlock 的返回信号 订阅 bindBlock 的返回信号，就会拿到绑定信号的订阅者，把处理完成的信号内容发送出来。 FlatternMap 和 Map 的区别 FlatternMap 中的Block 返回信号。 Map 中的Block 返回对象。 开发中，如果信号发出的值 不是信号 ，映射一般使用 Map 如果信号发出的值 是信号，映射一般使用 FlatternMap。 signalOfsignals用 FlatternMap 1234567891011121314151617181920212223// 创建信号中的信号RACSubject *signalOfsignals = [RACSubject subject];RACSubject *signal = [RACSubject subject];[[signalOfsignals flattenMap:^RACStream *(id value) &#123; // 当signalOfsignals的signals发出信号才会调用 return value;&#125;] subscribeNext:^(id x) &#123; // 只有signalOfsignals的signal发出信号才会调用，因为内部订阅了bindBlock中返回的信号，也就是flattenMap返回的信号。 // 也就是flattenMap返回的信号发出内容，才会调用。 NSLog(@&quot;signalOfsignals：%@&quot;,x);&#125;];// 信号的信号发送信号[signalOfsignals sendNext:signal];// 信号发送内容[signal sendNext:@&quot;hi&quot;]; 组合组合就是将多个信号按照某种规则进行拼接，合成新的信号。 concat 作用 按顺序拼接信号，当多个信号发出的时候，有顺序的接收信号。 底层实现 当拼接信号被订阅，就会调用拼接信号的didSubscribe didSubscribe中，会先订阅第一个源信号（signalA） 会执行第一个源信号（signalA）的didSubscribe 第一个源信号（signalA）didSubscribe中发送值，就会调用第一个源信号（signalA）订阅者的nextBlock,通过拼接信号的订阅者把值发送出来. 第一个源信号（signalA）didSubscribe中发送完成，就会调用第一个源信号（signalA）订阅者的completedBlock,订阅第二个源信号（signalB）这时候才激活（signalB）。 订阅第二个源信号（signalB）,执行第二个源信号（signalB）的didSubscribe 第二个源信号（signalA）didSubscribe中发送值,就会通过拼接信号的订阅者把值发送出来. 使用步骤 使用concat:拼接信号 订阅拼接信号，内部会自动按拼接顺序订阅信号 使用 拼接信号 signalA、 signalB、 signalC 12345678910111213141516171819202122232425262728293031323334353637383940RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;Hello&quot;]; [subscriber sendCompleted]; return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;World&quot;]; [subscriber sendCompleted]; return nil; &#125;]; RACSignal *signalC = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;!&quot;]; [subscriber sendCompleted]; return nil; &#125;]; // 拼接 A B, 把signalA拼接到signalB后，signalA发送完成，signalB才会被激活。 RACSignal *concatSignalAB = [signalA concat:signalB]; // A B + C RACSignal *concatSignalABC = [concatSignalAB concat:signalC]; // 订阅拼接的信号, 内部会按顺序订阅 A-&gt;B-&gt;C // 注意：第一个信号必须发送完成，第二个信号才会被激活... [concatSignalABC subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; then 作用 用于连接两个信号，当第一个信号完成，才会连接then返回的信号。 底层实现 先过滤掉之前的信号发出的值 使用concat连接then返回的信号 使用 1234567891011121314151617181920212223242526[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; [subscriber sendCompleted]; return nil; &#125;] then:^RACSignal *&#123; return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@2]; return nil; &#125;]; &#125;] subscribeNext:^(id x) &#123; // 只能接收到第二个信号的值，也就是then返回信号的值 NSLog(@&quot;%@&quot;, x); &#125;]; /// 输出：2 注意 注意使用then，之前信号的值会被忽略掉. merge 作用 合并信号,任何一个信号发送数据，都能监听到. 底层实现 合并信号被订阅的时候，就会遍历所有信号，并且发出这些信号。 每发出一个信号，这个信号就会被订阅 也就是合并信号一被订阅，就会订阅里面所有的信号。 只要有一个信号被发出就会被监听。 使用 12345678910111213141516171819202122232425RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;A&quot;]; return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;B&quot;]; return nil; &#125;]; // 合并信号, 任何一个信号发送数据，都能监听到 RACSignal *mergeSianl = [signalA merge:signalB]; [mergeSianl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; // 输出2017-01-03 13:29:08.013 ReactiveCocoa进阶[3627:718315] A2017-01-03 13:29:08.014 ReactiveCocoa进阶[3627:718315] B zip 作用 把两个信号压缩成一个信号，只有当两个信号 同时 发出信号内容时，并且把两个信号的内容合并成一个元组，才会触发压缩流的next事件。 底层实现 定义压缩信号，内部就会自动订阅signalA，signalB 每当signalA或者signalB发出信号，就会判断signalA，signalB有没有发出个信号，有就会把每个信号 第一次 发出的值包装成元组发出 使用 123456789101112131415161718192021222324252627282930313233RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;A1&quot;]; [subscriber sendNext:@&quot;A2&quot;]; return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;B1&quot;]; [subscriber sendNext:@&quot;B2&quot;]; [subscriber sendNext:@&quot;B3&quot;]; return nil; &#125;]; RACSignal *zipSignal = [signalA zipWith:signalB]; [zipSignal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;];// 输出2017-01-03 13:48:09.234 ReactiveCocoa进阶[3997:789720] zipWith: &lt;RACTuple: 0x600000004df0&gt; ( A1, B1)2017-01-03 13:48:09.234 ReactiveCocoa进阶[3997:789720] zipWith: &lt;RACTuple: 0x608000003410&gt; ( A2, B2) combineLatest 作用 将多个信号合并起来，并且拿到各个信号最后一个值,必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。 底层实现 当组合信号被订阅，内部会自动订阅signalA，signalB,必须两个信号都发出内容，才会被触发。 并且把两个信号的 最后一次 发送的值组合成元组发出。 使用 12345678910111213141516171819202122232425262728293031323334353637RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;A1&quot;]; [subscriber sendNext:@&quot;A2&quot;]; return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;B1&quot;]; [subscriber sendNext:@&quot;B2&quot;]; [subscriber sendNext:@&quot;B3&quot;]; return nil; &#125;]; RACSignal *combineSianal = [signalA combineLatestWith:signalB]; [combineSianal subscribeNext:^(id x) &#123; NSLog(@&quot;combineLatest:%@&quot;, x); &#125;];// 输出2017-01-03 13:48:09.235 ReactiveCocoa进阶[3997:789720] combineLatest:&lt;RACTuple: 0x60800000e150&gt; ( A2, B1)2017-01-03 13:48:09.235 ReactiveCocoa进阶[3997:789720] combineLatest:&lt;RACTuple: 0x600000004db0&gt; ( A2, B2)2017-01-03 13:48:09.236 ReactiveCocoa进阶[3997:789720] combineLatest:&lt;RACTuple: 0x60800000e180&gt; ( A2, B3) 注意 combineLatest与zip用法相似，必须每个合并的signal至少都有过一次sendNext，才会触发合并的信号。 区别看下图： reduce 作用 把信号发出元组的值聚合成一个值 底层实现 订阅聚合信号， 每次有内容发出，就会执行reduceblcok，把信号内容转换成reduceblcok返回的值。 使用 常见的用法，（先组合在聚合）combineLatest:(id&lt;NSFastEnumeration&gt;)signals reduce:(id (^)())reduceBlock reduce中的block简介: reduceblcok中的参数，有多少信号组合，reduceblcok就有多少参数，每个参数就是之前信号发出的内容 reduceblcok的返回值：聚合信号之后的内容。 1234567891011121314151617181920212223242526272829303132 RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;A1&quot;]; [subscriber sendNext:@&quot;A2&quot;]; return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;B1&quot;]; [subscriber sendNext:@&quot;B2&quot;]; [subscriber sendNext:@&quot;B3&quot;]; return nil; &#125;]; RACSignal *reduceSignal = [RACSignal combineLatest:@[signalA, signalB] reduce:^id(NSString *str1, NSString *str2)&#123; return [NSString stringWithFormat:@&quot;%@ %@&quot;, str1, str2]; &#125;]; [reduceSignal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; // 输出 2017-01-03 15:42:41.803 ReactiveCocoa进阶[4248:1264674] A2 B12017-01-03 15:42:41.803 ReactiveCocoa进阶[4248:1264674] A2 B22017-01-03 15:42:41.803 ReactiveCocoa进阶[4248:1264674] A2 B3 过滤过滤就是过滤信号中的 特定值 ，或者过滤指定 发送次数 的信号。 filter 作用 过滤信号，使用它可以获取满足条件的信号. block的返回值是Bool值，返回NO则过滤该信号 使用 1234567891011121314151617181920212223// 过滤:// 每次信号发出，会先执行过滤条件判断.[[_textField.rac_textSignal filter:^BOOL(NSString *value) &#123; NSLog(@&quot;原信号: %@&quot;, value); // 过滤 长度 &lt;= 3 的信号 return value.length &gt; 3; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;长度大于3的信号：%@&quot;, x); &#125;]; // 在_textField中输出12345// 输出2017-01-03 16:36:54.938 ReactiveCocoa进阶[4714:1552910] 原信号: 12017-01-03 16:36:55.383 ReactiveCocoa进阶[4714:1552910] 原信号: 122017-01-03 16:36:55.706 ReactiveCocoa进阶[4714:1552910] 原信号: 1232017-01-03 16:36:56.842 ReactiveCocoa进阶[4714:1552910] 原信号: 12342017-01-03 16:36:56.842 ReactiveCocoa进阶[4714:1552910] 长度大于3的信号：12342017-01-03 16:36:58.350 ReactiveCocoa进阶[4714:1552910] 原信号: 123452017-01-03 16:36:58.351 ReactiveCocoa进阶[4714:1552910] 长度大于3的信号：12345 ignore 作用 忽略某些信号. 使用 作用 忽略某些值的信号. 底层调用了 filter 与 过滤值进行比较，若相等返回则 NO 使用 12345 // 内部调用filter过滤，忽略掉字符为 @“1”的值[[_textField.rac_textSignal ignore:@&quot;1&quot;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; distinctUntilChanged 作用 当上一次的值和当前的值有明显的变化就会发出信号，否则会被忽略掉。 使用 1234[[_textField.rac_textSignal distinctUntilChanged] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;]; skip 作用 跳过 第N次 的发送的信号. 使用 12345// 表示输入第一次，不会被监听到，跳过第一次发出的信号[[_textField.rac_textSignal skip:1] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x);&#125;]; take 作用 取 前N次 的发送的信号. 使用 123456789101112131415RACSubject *subject = [RACSubject subject] ; // 取 前两次 发送的信号 [[subject take:2] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; [subject sendNext:@1]; [subject sendNext:@2]; [subject sendNext:@3]; // 输出2017-01-03 17:35:54.566 ReactiveCocoa进阶[4969:1677908] 12017-01-03 17:35:54.567 ReactiveCocoa进阶[4969:1677908] 2 takeLast 作用 取 最后N次 的发送的信号 前提条件，订阅者必须调用完成 sendCompleted，因为只有完成，就知道总共有多少信号. 使用 1234567891011121314RACSubject *subject = [RACSubject subject] ; // 取 后两次 发送的信号 [[subject takeLast:2] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; [subject sendNext:@1]; [subject sendNext:@2]; [subject sendNext:@3]; // 必须 跳用完成 [subject sendCompleted]; takeUntil 作用 获取信号直到某个信号执行完成 使用 12 // 监听文本框的改变直到当前对象被销毁[_textField.rac_textSignal takeUntil:self.rac_willDeallocSignal]; switchToLatest 作用 用于signalOfSignals（信号的信号），有时候信号也会发出信号，会在signalOfSignals中，获取signalOfSignals发送的最新信号。 注意 switchToLatest：只能用于信号中的信号 使用 1234567891011RACSubject *signalOfSignals = [RACSubject subject]; RACSubject *signal = [RACSubject subject]; // 获取信号中信号最近发出信号，订阅最近发出的信号。 [signalOfSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; [signalOfSignals sendNext:signal]; [signal sendNext:@1]; 秩序秩序包括 doNext 和 doCompleted 这两个方法，主要是在 执行sendNext 或者 sendCompleted之前，先执行这些方法中Block。 doNext执行sendNext之前，会先执行这个doNext的 Block doCompleted执行sendCompleted之前，会先执行这doCompleted的Block 123456789101112131415161718192021[[[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;hi&quot;]; [subscriber sendCompleted]; return nil; &#125;] doNext:^(id x) &#123; // 执行 [subscriber sendNext:@&quot;hi&quot;] 之前会调用这个 Block NSLog(@&quot;doNext&quot;); &#125;] doCompleted:^&#123; // 执行 [subscriber sendCompleted] 之前会调用这 Block NSLog(@&quot;doCompleted&quot;);&#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x);&#125;]; 线程ReactiveCocoa 中的线程操作 包括 deliverOn 和 subscribeOn这两种，将 传递的内容 或 创建信号时 block中的代码 切换到指定的线程中执行。 deliverOn 作用 内容传递切换到制定线程中，副作用在原来线程中,把在创建信号时block中的代码称之为副作用。 使用 123456789101112131415161718192021222324252627 // 在子线程中执行 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;%@&quot;, [NSThread currentThread]); [subscriber sendNext:@123]; [subscriber sendCompleted]; return nil; &#125;] deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); NSLog(@&quot;%@&quot;, [NSThread currentThread]); &#125;]; &#125;); // 输出2017-01-04 10:35:55.415 ReactiveCocoa进阶[1183:224535] &lt;NSThread: 0x608000270f00&gt;&#123;number = 3, name = (null)&#125;2017-01-04 10:35:55.415 ReactiveCocoa进阶[1183:224482] 1232017-01-04 10:35:55.415 ReactiveCocoa进阶[1183:224482] &lt;NSThread: 0x600000079bc0&gt;&#123;number = 1, name = main&#125; 可以看到`副作用`在 *子线程* 中执行，而 `传递的内容` 在 *主线程* 中接收 subscribeOn 作用 subscribeOn则是将 内容传递 和 副作用 都会切换到指定线程中 使用 123456789101112131415161718192021222324 dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;%@&quot;, [NSThread currentThread]); [subscriber sendNext:@123]; [subscriber sendCompleted]; return nil; &#125;] subscribeOn:[RACScheduler mainThreadScheduler]] //传递的内容到主线程中 subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); NSLog(@&quot;%@&quot;, [NSThread currentThread]); &#125;]; &#125;); //2017-01-04 10:44:47.558 ReactiveCocoa进阶[1243:275126] &lt;NSThread: 0x608000077640&gt;&#123;number = 1, name = main&#125;2017-01-04 10:44:47.558 ReactiveCocoa进阶[1243:275126] 1232017-01-04 10:44:47.558 ReactiveCocoa进阶[1243:275126] &lt;NSThread: 0x608000077640&gt;&#123;number = 1, name = main&#125; `内容传递` 和 `副作用` 都切换到了 *主线程* 执行 时间时间操作就会设置信号超时，定时和延时。 interval 定时 作用 定时：每隔一段时间发出信号 12345678910// 每隔1秒发送信号，指定当前线程执行[[RACSignal interval:1 onScheduler:[RACScheduler currentScheduler]] subscribeNext:^(id x) &#123; NSLog(@&quot;定时:%@&quot;, x); &#125;]; // 输出2017-01-04 13:48:55.196 ReactiveCocoa进阶[1980:492724] 定时:2017-01-04 05:48:55 +00002017-01-04 13:48:56.195 ReactiveCocoa进阶[1980:492724] 定时:2017-01-04 05:48:56 +00002017-01-04 13:48:57.196 ReactiveCocoa进阶[1980:492724] 定时:2017-01-04 05:48:57 +0000 timeout 超时 作用 超时，可以让一个信号在一定的时间后，自动报错。 12345678910111213141516171819RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 不发送信号，模拟超时状态 // [subscriber sendNext:@&quot;hello&quot;]; //[subscriber sendCompleted]; return nil; &#125;] timeout:1 onScheduler:[RACScheduler currentScheduler]];// 设置1秒超时 [signal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125; error:^(NSError *error) &#123; NSLog(@&quot;%@&quot;, error); &#125;]; // 执行代码 1秒后 输出： 2017-01-04 13:48:55.195 ReactiveCocoa进阶[1980:492724] Error Domain=RACSignalErrorDomain Code=1 &quot;(null)&quot; delay 延时 作用 延时，延迟一段时间后发送信号 123456789101112RACSignal *signal2 = [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;延迟输出&quot;]; return nil; &#125;] delay:2] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; // 执行代码 2秒后 输出 2017-01-04 13:55:23.751 ReactiveCocoa进阶[2030:525038] 延迟输出 重复retry 作用 重试：只要 发送错误 sendError:,就会 重新执行 创建信号的Block 直到成功 123456789101112131415161718192021222324252627282930313233343536 __block int i = 0; [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; if (i == 5) &#123; [subscriber sendNext:@&quot;Hello&quot;]; &#125; else &#123; // 发送错误 NSLog(@&quot;收到错误:%d&quot;, i); [subscriber sendError:nil]; &#125; i++; return nil; &#125;] retry] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125; error:^(NSError *error) &#123; NSLog(@&quot;%@&quot;, error); &#125;]; // 输出2017-01-04 14:36:51.594 ReactiveCocoa进阶[2443:667226] 收到错误信息:02017-01-04 14:36:51.595 ReactiveCocoa进阶[2443:667226] 收到错误信息:12017-01-04 14:36:51.595 ReactiveCocoa进阶[2443:667226] 收到错误信息:22017-01-04 14:36:51.596 ReactiveCocoa进阶[2443:667226] 收到错误信息:32017-01-04 14:36:51.596 ReactiveCocoa进阶[2443:667226] 收到错误信息:42017-01-04 14:36:51.596 ReactiveCocoa进阶[2443:667226] Hello replay 作用 重放：当一个信号被多次订阅,反复播放内容 123456789101112131415161718192021 RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@1]; [subscriber sendNext:@2]; return nil; &#125;] replay]; [signal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; [signal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; // 输出2017-01-04 14:51:01.934 ReactiveCocoa进阶[2544:706740] 12017-01-04 14:51:01.934 ReactiveCocoa进阶[2544:706740] 22017-01-04 14:51:01.934 ReactiveCocoa进阶[2544:706740] 12017-01-04 14:51:01.935 ReactiveCocoa进阶[2544:706740] 2 throttle 作用 节流:当某个信号发送比较频繁时，可以使用节流，在某一段时间不发送信号内容，过了一段时间获取信号的最新内容发出。 1234567891011121314RACSubject *subject = [RACSubject subject]; // 节流1秒，1秒后接收最后一个发送的信号 [[subject throttle:1] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x); &#125;]; [subject sendNext:@1]; [subject sendNext:@2]; [subject sendNext:@3]; // 输出 2017-01-04 15:02:37.543 ReactiveCocoa进阶[2731:758193] 3 MVVM架构思想 程序为什么要有架构？便于程序开发与维护. 常见的架构 MVC M:模型 V:视图 C:控制器 MVVM M:模型 V:视图+控制器 VM:视图模型 MVCS M:模型 V:视图 C:控制器 C:服务类 VIPER V:视图 I:交互器 P:展示器 E:实体 R:路由 MVVM介绍 模型(M):保存视图数据。 视图+控制器(V):展示内容 + 如何展示 视图模型(VM):处理展示的业务逻辑，包括按钮的点击，数据的请求和解析等等。 实战一：登录界面需求 监听两个文本框的内容 有内容登录按键才允许按钮点击 返回登录结果 分析 界面的所有业务逻辑都交给控制器做处理 在MVVM架构中把控制器的业务全部搬去VM模型，也就是每个控制器对应一个VM模型. 步骤 创建LoginViewModel类，处理登录界面业务逻辑. 这个类里面应该保存着账号的信息，创建一个账号Account模型 LoginViewModel应该保存着账号信息Account模型。 需要时刻监听Account模型中的账号和密码的改变，怎么监听？ 在非RAC开发中，都是习惯赋值，在RAC开发中，需要改变开发思维，由赋值转变为绑定，可以在一开始初始化的时候，就给Account模型中的属性绑定，并不需要重写set方法。 每次Account模型的值改变，就需要判断按钮能否点击，在VM模型中做处理，给外界提供一个能否点击按钮的信号. 这个登录信号需要判断Account中账号和密码是否有值，用KVO监听这两个值的改变，把他们聚合成登录信号. 监听按钮的点击，由VM处理，应该给VM声明一个RACCommand，专门处理登录业务逻辑. 执行命令，把数据包装成信号传递出去 监听命令中信号的数据传递 监听命令的执行时刻 运行效果 代码MyViewController.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#import &quot;MyViewController.h&quot;#import &quot;LoginViewModel.h&quot;@interface MyViewController ()@property (nonatomic, strong) LoginViewModel *loginViewModel;@property (weak, nonatomic) IBOutlet UITextField *accountField;@property (weak, nonatomic) IBOutlet UITextField *pwdField;@property (weak, nonatomic) IBOutlet UIButton *loginBtn;@end@implementation MyViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self bindModel]; &#125;- (void)didReceiveMemoryWarning &#123; [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.&#125;// 视图模型绑定- (void)bindModel &#123; // 给模型的属性绑定信号 // RAC(self.loginViewModel.account, account) = _accountField.rac_textSignal; RAC(self.loginViewModel.account, pwd) = _pwdField.rac_textSignal; RAC(self.loginBtn, enabled) = self.loginViewModel.enableLoginSignal; // 监听登录点击 [[_loginBtn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; [self.loginViewModel.LoginCommand execute:nil]; &#125;]; &#125;- (IBAction)btnTap:(id)sender &#123; &#125;#pragma mark - lazyLoad- (LoginViewModel *)loginViewModel &#123; if (nil == _loginViewModel) &#123; _loginViewModel = [[LoginViewModel alloc] init]; &#125; return _loginViewModel;&#125;``` `LoginViewModel.h` #import &lt;UIKit/UIKit.h&gt; @interface Account : NSObject @property (nonatomic, strong) NSString account;@property (nonatomic, strong) NSString pwd; @end @interface LoginViewModel : UIViewController @property (nonatomic, strong) Account *account; // 是否允许登录的信号@property (nonatomic, strong, readonly) RACSignal *enableLoginSignal; @property (nonatomic, strong, readonly) RACCommand *LoginCommand; @end 12`LoginViewModel.m` #import “LoginViewModel.h” @implementation Account @end @interface LoginViewModel () @end @implementation LoginViewModel (instancetype)init { if (self = [super init]) { [self initialBind]; } return self;} (void)initialBind { // 监听账号属性改变， 把他们合成一个信号 _enableLoginSignal = [RACSubject combineLatest:@[RACObserve(self.account, account), RACObserve(self.account, pwd)] reduce:^id(NSString accout, NSString pwd){ return @(accout.length &amp;&amp; pwd.length); }]; // 处理业务逻辑 _LoginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) { NSLog(@&quot;点击了登录&quot;); return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { // 模仿网络延迟 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{ // 返回登录成功 发送成功信号 [subscriber sendNext:@&quot;登录成功&quot;]; }); return nil; }]; }]; // 监听登录产生的数据 [_LoginCommand.executionSignals.switchToLatest subscribeNext:^(id x) { if ([x isEqualToString:@&quot;登录成功&quot;]) { NSLog(@&quot;登录成功&quot;); } }]; [[_LoginCommand.executing skip:1] subscribeNext:^(id x) { if ([x isEqualToNumber:@(YES)]) { NSLog(@&quot;正在登陆...&quot;); } else { // 登录成功 NSLog(@&quot;登陆成功&quot;); } }]; } #pragma mark - lazyLoad (Account *)account{ if (_account == nil) { _account = [[Account alloc] init]; } return _account;} (void)viewDidLoad { [super viewDidLoad]; } @end 123456789101112131415161718192021# 实战二：网络请求数据#### 需求1. 请求一段网络数据，将请求到的数据在`tableView`上展示2. 该数据为豆瓣图书的搜索返回结果，URL：url:https://api.douban.com/v2/book/search?q=悟空传#### 分析1. 界面的所有业务逻辑都交给**控制器**做处理2. 网络请求交给**MV**模型处理#### 步骤1. 控制器提供一个视图模型（requesViewModel），处理界面的业务逻辑2. VM提供一个命令，处理请求业务逻辑3. 在创建命令的block中，会把请求包装成一个信号，等请求成功的时候，就会把数据传递出去。4. 请求数据成功，应该把字典转换成模型，保存到视图模型中，控制器想用就直接从视图模型中获取。#### 其他网络请求与图片缓存用到了[AFNetworking](https://github.com/AFNetworking/AFNetworking) 和 [SDWebImage](https://github.com/rs/SDWebImage),自行在Pods中导入。 platform :ios, ‘8.0’ target ‘ReactiveCocoa进阶’ do use_frameworks!pod ‘ReactiveCocoa’, ‘~&gt; 2.5’pod ‘AFNetworking’pod ‘SDWebImage’end123456789#### 运行效果![](https://ww3.sinaimg.cn/large/006y8lVagw1fbgw1xnz74j30bj0l4408.jpg)#### 代码`SearchViewController.m` #import “SearchViewController.h” #import “RequestViewModel.h” @interface SearchViewController () @property (nonatomic, strong) UITableView *tableView; @property (nonatomic, strong) RequestViewModel *requesViewModel; @end @implementation SearchViewController (RequestViewModel *)requesViewModel{ if (_requesViewModel == nil) { _requesViewModel = [[RequestViewModel alloc] init]; } return _requesViewModel;} (void)viewDidLoad { [super viewDidLoad]; self.tableView = [[UITableView alloc] initWithFrame:self.view.frame]; self.tableView.dataSource = self; [self.view addSubview:self.tableView]; // RACSignal *requesSiganl = [self.requesViewModel.reuqesCommand execute:nil]; [requesSiganl subscribeNext:^(NSArray *x) { self.requesViewModel.models = x; [self.tableView reloadData]; }]; } (void)didReceiveMemoryWarning { [super didReceiveMemoryWarning]; // Dispose of any resources that can be recreated.} (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section{ return self.requesViewModel.models.count;} (UITableViewCell )tableView:(UITableView )tableView cellForRowAtIndexPath:(NSIndexPath )indexPath{ static NSString ID = @”cell”; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:ID]; if (cell == nil) { cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleSubtitle reuseIdentifier:ID]; } Book *book = self.requesViewModel.models[indexPath.row]; cell.detailTextLabel.text = book.subtitle; cell.textLabel.text = book.title; [cell.imageView sd_setImageWithURL:[NSURL URLWithString:book.image] placeholderImage:[UIImage imageNamed:@”cellImage”]]; return cell; }@end12`RequestViewModel.h` #import &lt;Foundation/Foundation.h&gt; @interface Book : NSObject @property (nonatomic, copy) NSString subtitle;@property (nonatomic, copy) NSString title;@property (nonatomic, copy) NSString *image; @end @interface RequestViewModel : NSObject // 请求命令@property (nonatomic, strong, readonly) RACCommand *reuqesCommand; //模型数组@property (nonatomic, strong) NSArray *models; @end12`RequestViewModel.m` #import “RequestViewModel.h” @implementation Book (instancetype)initWithValue:(NSDictionary *)value { if (self = [super init]) { self.title = value[@&quot;title&quot;]; self.subtitle = value[@&quot;subtitle&quot;]; self.image = value[@&quot;image&quot;]; } return self;} (Book )bookWithDict:(NSDictionary )value { return [[self alloc] initWithValue:value];} @end @implementation RequestViewModel (instancetype)init{ if (self = [super init]) { [self initialBind]; } return self;} (void)initialBind{ _reuqesCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) { RACSignal *requestSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) { NSMutableDictionary *parameters = [NSMutableDictionary dictionary]; parameters[@&quot;q&quot;] = @&quot;悟空传&quot;; // [[AFHTTPSessionManager manager] GET:@&quot;https://api.douban.com/v2/book/search&quot; parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) { NSLog(@&quot;downloadProgress: %@&quot;, downloadProgress); } success:^(NSURLSessionDataTask * _Nonnull task, id _Nullable responseObject) { // 数据请求成功就讲数据发送出去 NSLog(@&quot;responseObject:%@&quot;, responseObject); [subscriber sendNext:responseObject]; [subscriber sendCompleted]; } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) { NSLog(@&quot;error: %@&quot;, error); }]; return nil; }]; // 在返回数据信号时，把数据中的字典映射成模型信号，传递出去 return [requestSiganl map:^id(NSDictionary *value) { NSMutableArray *dictArr = value[@&quot;books&quot;]; NSArray *modelArr = [[dictArr.rac_sequence map:^id(id value) { return [Book bookWithDict:value]; }] array]; return modelArr; }]; }]; } @end ` 最后附上GitHub：https://github.com/qiubaiying/ReactiveCocoa_Demo]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>ReactiveCocoa</tag>
        <tag>函数式编程</tag>
        <tag>开源框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello 2018]]></title>
    <url>%2F2018%2F07%2F18%2FHello-2018%2F</url>
    <content type="text"><![CDATA[“🙉🙉🙉 ” 前言BY 的 Blog 就这么开通了。 本来打算在年前完成 Blog 的搭建，不曾料想踩了很多坑。。。 跳过废话，直接看技术实现 2018 年暑假，BY Blog 总算是搭建好了。 最开始写博客是在简书这个平台上，简书确实不错，支持markdown在线编辑。 在一次偶然间，听到我的好基友 阳阳 想搭建个人主页，觉得作为一个程序员，是应该倒腾倒腾自己的Blog，于是乎就开始了撸起袖子干了。 正文接下来说说搭建这个博客的技术细节。 正好之前就有关注过 GitHub Pages + Jekyll 快速 Building Blog 的技术方案，非常轻松时尚。 其优点非常明显： Markdown 带来的优雅写作体验 非常熟悉的 Git workflow ，Git Commit 即 Blog Post 利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机 如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了 Jekyll 的自定制非常容易，基本就是个模版引擎 主题我直接 Downlosd 了 Hux的博客主题 的进行修改，简单粗暴，不过遇到了很多坑😂，好在都填完了。。。 本地调试环境需要 gem install jekyll，结果 rubygem 的源居然被墙了，后来手动改成了我大淘宝的镜像源才成功，淘宝的源已经停止维护，换成了OSChina的源 https://gems.ruby-china.org/。 后记最后，感谢 Hux 提供的的 Blog 主题 如果你恰好逛到了这里，希望你也能喜欢这个博客主题，感兴趣的话可以自己动手搭建一个。 —— BY 后记于 2018.07]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[柔术最大的谎言「译」]]></title>
    <url>%2F2018%2F01%2F04%2F%E6%9F%94%E6%9C%AF%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B0%8E%E8%A8%80%E3%80%8C%E8%AF%91%E3%80%8D%2F</url>
    <content type="text"><![CDATA[译自 《THE BIGGEST LIE IN JIU JITSU》 最近我看到了一个让我捧腹的柔术笑话。 “柔术的技术是无敌的！” 你可能不想听听下面的内容，但是作为一名柔术教练，我的工作是与你分享我认为的真理，而不是虚假的谎言。所以在这里与你们分享我的见解： 目录 技术不是无敌的 我的见解 一个假设 真实的例子 这个神话是从哪里来的？ 好消息 如何变得更强 你该怎么做 技术不是无敌的基础运动能力，特别是力量，对柔术的表现起着巨大的作用，而且往往可以克服技巧。尽管你被告知了卓越的技术并不总是能克服体型和力量优势。但在我看来，力量和技术一样重要。 我的见解我练习巴西柔术将近二十年，已经是一个黑带了。我认为自己是一个技术顶尖的柔术运动员，我致力于使自己的技术动作更加高效和精准。 但是这里有个小秘密：有时候，我会利用力量强行完成一个柔术动作。我并不常这样做，但我明白力量对于柔术的重要性，并且它可以更好的帮助我完成动作，我已经认识到这样做是正确的。 我的脑袋中仍然有一种“无力游戏”的想法，那就是我技术非常优秀，以至于我不需要出力就可以降服对手。但我知道这只是我的一个天真的想法。 是的，世界顶尖的柔术运动员毫无疑问都拥有顶尖的柔术技术。但是，他们无一例外都是非常强壮的人。由于先天的遗传和后天科学的训练，这些家伙拥有不可思议的力量和体格。 我的经验得出的这个等式适用与大多数情况： 运动员A（中等技术 + 上等身体素质） &gt; 运动员B（上等技术 + 下等身体素质） 一个假设我知道你还不相信我，所以我会用一个例子来说明我的观点。让我们来看看使用两个战士 Steve 和 JoJo 的假想情景。 Steve:Steve 5岁开始学习柔术，由马塞洛·加西亚，拉法·门德斯和瑞克森·格雷西执教。它学会了他们所有的技巧，并且吸收了他们所有关于压力，时间和人体力学的智慧。他在接下来的13年里每周训练6天。 18岁，体重200磅的 Steve 击败了所有对手取得了 IBJJF（国际巴西柔术联合会）世界锦标赛的棕色带中量级冠军，并且立即被授予黑带。第二年，在对战拥有绝对黑带实力的 Buchecha（开头照片中的人）的决赛中，用了一个飞身十字固在13秒内降服了他。 JoJo：JoJo 是一个10岁的银背大猩猩。他体重400磅。他从未接受过柔术或其他武术的训练。 一决胜负：假设 JoJo 与 Steve 展开一场柔术规则的比赛。 你认为谁会赢得这场比赛？如果你认为 Steve 会用他的“无敌技巧”击败 JoJo，那么你就是妄想。（此外，你可以用 点穴 试试~） JoJo 的体格与力量优势根本无法用技术来克服。 真实的例子好吧，上面的例子非常不切实际，根本不会发生。但是，我可以举一些我身边的例子： 例子1:在2013年，我亲眼目睹了世界冠军中，一位黑带女性与体重相同的紫色带男性的比赛，他们在一个开放的垫子上打成一片。这个女人一点机会都没有。她在6分钟内拍垫近十次。 那么现在是因为“女人不擅长柔术”还是因为“男人比女人好”呢？当然不是。这只是一个简单的力量问题。这位男性拥有更高的睾酮水平，因此拥有更强大的结缔组织和更多的肌肉。 例子2:我有一个朋友身高 1.95m，重达 300磅（136kg），是一个前NCAA中后卫球员。同时他也是柔术棕色腰带。他可以（而且经常）很容易地只用一只手臂将我从地面上抬起。当我们滚动时他绝对砸我，这时候基本上我是无能为力的。 这是否因为他的技术比我好？当然不是。我的训练的时间比他更长，训练频率和强度要高得多。这是因为他比我更高，更大，更强壮。 例子3:我的正常体重大约是203磅（92kg）。有时，由于各种原因，包括力量训练计划，肌酸周期或假日过度放纵，可能会高达218甚至220磅。 因为我一直在垫子上呆着，所以我可以敏锐的察觉到体重对于柔术的影响。我可以直接告诉你：你越重，对抗越轻松。我可以更轻松的控制体重较轻的对手，并且能对抗更长的时间。 这个神话是从哪里来的？传统武术的胡扯这个误解也是传统武术的骗人的精髓所在。告诉一个弱小的人学习了某种武术，他就轻松可以击败比他高大，更强壮的坏人。 在20世纪，一个巨大的产业就建立在这个基础之上，各种乱七八糟的武术系统被包装并推给了好骗的西方人。尽管MMA中的柔术技术帮助清除了许多武术的骗局，但现在仍然受到影响。 柔术课的结构还有一部分原因是由于柔术学院商业模式的本质。虽然柔术比赛竞争激烈，但是现在的柔术学院通常还只是围绕着技术动作和实战对抗这两个方面进行教学和训练。因此，早期的先驱者重视身体训练，这是有道理的。 乔治·圣皮埃尔的教练Firhas Zahabi曾经对我说过。“随着柔术学院商业化的推广，我们看到了很多必要的体能训练消失了。”他说的对，在绝大多数的柔术学院中，体能训练并不被重视。当然，你也可以做一些跳跃俯卧撑和俯卧撑作为热身的一部分，但这还远远不够。看看拳击手和摔跤手。体能训练往往是他们训练的最重要的组成部分，而对抗往往是花时间最小的一个。 罗伊斯·格雷斯 与 UFC罗伊斯·格雷西（Royce Gracie）在 UFC 早期的比赛中的惊人表现导致了一些人相信技术确实是无敌的。在我看来，罗伊斯赢了，因为他打的比赛看起来像这样： 斗士A（中等属性+强大的技术）&gt; 斗士B（伟大的属性+没有技术） 由于第二代 MMA 斗士的的属性已经改变，因为家伙们已经开始学习柔术了。比赛开始更像这样： 斗士A（中等属性+强大技术）≥ 斗士B（强大属性+一点点技巧） 在如今的 MMA 比赛中，我们经常看到的情况是这样的： 斗士A（卓越的属性+伟大的技术）&gt; 斗士B（伟大的属性+伟大的技术） 杠杠原理的迷惑杠杠原理能成倍加强力量，但不是力量的来源。当然，杠杠原理能帮你能更有效的利用力量，但没有力量来源，这个杠杠力也不复存在。这就是‘柔术’中‘杠杠原理’这个概念的迷惑性。 尽管可能会有人告诉你，没有人能为柔术添加杠杠作用。但是一些聪明的运动员及教练确实能够准确的找到杠杠的支点，并且使用的力量来完成动作，效果惊人。 好消息好消息是就算你只进行柔术对抗训练也能自然而然的提升你的体能，尽管这个提升有局限性并且基因决定了你的体能极限（抱歉，就是这样），而通过科学而且集中体能训练可以大幅度提升你的体能。 同时，体型小的训练者并不是总是处于劣势。相对力量会随着体型的增加而减小。所以假设其他条件相同的情况下，一个体重比你大20%的对手，力量并不会比你大20%，通常这个值会是12%~15%。这就意味着那些拥有惊人身体的小个子训练者通常会扳平体型的劣势，有时候甚至还会反超。 最后一个就是力量的增长也会随着年龄的增长而称下降的趋势，并在年老的时候就维持不变了。“人的力量就是这么真实”。 如何变得更强检查你的激素水平如果你是一个男性柔术运动员，我建议你去内分泌专家那检查你的激素水平。如果你的睾丸酮激素水平过低，不管你如何训练，你的身体素质都不会有较大的提升。一个好医生会建议你使用多种补剂和药品来解决这个问题。 体操总体来说，拥有了功能性力量与身体控制能力，你将很难被击败。如果让我在力量训练之外再挑选一个最为柔术的赋值训练，那就是体操了。 攀岩另一项能直接对柔术的运动表现及其力量提升极大的运动就是攀岩了，尤其是握力。 举重举重对运动表现的提升不是通过几组二头弯举或者卧推就可以的，那是健身。你需要在专业教练的指导下练习奥运举和力量举（例如挺举，深蹲）。 你该怎么做提高柔术水平不仅仅是提升柔术技术。我喜欢柔术的技术，它是那样的直接有效，令人着迷。如果你想在道垫上降服对手，高质量的动作是必不可少的。但这还不够。你可以在这篇文章中找到答案。 真正的武术家是一个在各个方面力精益求精的人。这包括变得更加强壮。如果你想成为顶级的柔术家，将你的体能提升到极限是你的必修课。]]></content>
      <tags>
        <tag>BJJ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从一道网易面试题浅谈 Tagged Pointer]]></title>
    <url>%2F2017%2F12%2F26%2F%E4%BB%8E%E4%B8%80%E9%81%93%E7%BD%91%E6%98%93%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B5%85%E8%B0%88-Tagged-Pointer%2F</url>
    <content type="text"><![CDATA[前言这篇博客九月就想写了，因为赶项目拖了到现在，抓住17年尾巴写吧~ 正文上次看了一篇 《从一道网易面试题浅谈OC线程安全》 的博客，主要内容是： 作者去网易面试，面试官出了一道面试题：下面代码会发生什么问题？ 12345678@property (nonatomic, strong) NSString *target;//....dispatch_queue_t queue = dispatch_queue_create("parallel", DISPATCH_QUEUE_CONCURRENT);for (int i = 0; i &lt; 1000000 ; i++) &#123; dispatch_async(queue, ^&#123; self.target = [NSString stringWithFormat:@"ksddkjalkjd%d",i]; &#125;);&#125; 答案是：会 crash。 我们来看看对target属性（strong修饰）进行赋值，相当与 MRC 中的 1234567- (void)setTarget:(NSString *)target &#123; if (target == _target) return; id pre = _target; [target retain];//1.先保留新值 _target = target;//2.再进行赋值 [pre release];//3.释放旧值&#125; 因为在 并行队列 DISPATCH_QUEUE_CONCURRENT 中异步 dispatch_async 对 target属性进行赋值，就会导致 target 已经被 release了，还会执行 release。这就是向已释放内存对象发送消息而发生 crash 。 但是我敲了这段代码，执行的时候发现并不会 crash~ 12345678@property (nonatomic, strong) NSString *target;dispatch_queue_t queue = dispatch_queue_create("parallel", DISPATCH_QUEUE_CONCURRENT);for (int i = 0; i &lt; 1000000 ; i++) &#123; dispatch_async(queue, ^&#123; // ‘ksddkjalkjd’删除了 self.target = [NSString stringWithFormat:@"%d",i]; &#125;);&#125; 原因就出在对 self.target 赋值的字符串上。博客的最后也提到了 - ‘上述代码的字符串改短一些，就不会崩溃’，还有 Tagged Pointer 这个东西。 我们将上面的代码修改下： 123NSString *str = [NSString stringWithFormat:@"%d", i];NSLog(@"%d, %s, %p", i, object_getClassName(str), str);self.target = str; 输出： 10, NSTaggedPointerString, 0x3015 发现这个字符串类型是 NSTaggedPointerString，那我们来看看 Tagged Pointer 是什么？ Tagged PointerTagged Pointer 详细的内容可以看这里 深入理解Tagged Pointer。 Tagged Pointer 是一个能够提升性能、节省内存的有趣的技术。 Tagged Pointer 专门用来存储小的对象，例如 NSNumber 和 NSDate（后来可以存储小字符串） Tagged Pointer 指针的值不再是地址了，而是真正的值。所以，实际上它不再是一个对象了，它只是一个披着对象皮的普通变量而已。 它的内存并不存储在堆中，也不需要 malloc 和 free，所以拥有极快的读取和创建速度。 参考： 从一道网易面试题浅谈OC线程安全 深入理解Tagged Pointer 【译】采用Tagged Pointer的字符串]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为博客添加 Gitalk 评论插件]]></title>
    <url>%2F2017%2F12%2F19%2F%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0-Gitalk-%E8%AF%84%E8%AE%BA%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言由于 Disqus 对于国内网路的支持十分糟糕，很多人反映 Disqus 评论插件一直加载不出来。而我一直是处于翻墙状态的~（话说你们做程序员的都不翻墙用Google的吗😅，哈哈，吐嘈下） 针对这个问题，我添加了Gitalk 评论插件。在此，非常感谢 @FeDemo 的推荐 。 正文Gitalk 评论插件首先来看看 Gitalk 的界面和功能： gitalk 使用 Github 帐号登录，界面干净整洁，最喜欢的一点是支持 MarkDown语法。 原理Gitalk 是一个利用 Github API,基于 Github issue 和 Preact 开发的评论插件，在 Gitalk 之前还有一个 gitment 插件也是基于这个原理开发的,不过 gitment 已经很久没人维护了。 可以看到在 gitalk 的评论框进行评论时，其实就是在对应的 issue 上提问题。 集成 Gitalk到这里，你应该对 Gitalk 有个大致的了解了，现在，开始集成 gitalk 插件吧。 将这段代码插入到你的网站： 1234567891011121314151617181920212223&lt;!-- Gitalk 评论 start --&gt;&#123;% if site.gitalk.enable %&#125;&lt;!-- Link Gitalk 的支持文件 --&gt;&lt;link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"&gt;&lt;script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"&gt;&lt;/script&gt;&lt;div id="gitalk-container"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; var gitalk = new Gitalk(&#123; // gitalk的主要参数 clientID: `Github Application clientID`, clientSecret: `Github Application clientSecret`, repo: `存储你评论 issue 的 Github 仓库名`, owner: 'Github 用户名', admin: ['Github 用户名'], id: '页面的唯一标识，gitalk会根据这个标识自动创建的issue的标签', &#125;); gitalk.render('gitalk-container');&lt;/script&gt;&#123;% endif %&#125;&lt;!-- Gitalk end --&gt; 我们需要关心的就是配置下面几个参数： 123456clientID: `Github Application clientID`,clientSecret: `Github Application clientSecret`,repo: `Github 仓库名`,//存储你评论 issue 的 Github 仓库名（建议直接用 GitHub Page 的仓库名）owner: 'Github 用户名',admin: ['Github 用户名'], //这个仓库的管理员，可以有多个，用数组表示，一般写自己,id: 'window.location.pathname', //页面的唯一标识，gitalk 会根据这个标识自动创建的issue的标签,我们使用页面的相对路径作为标识 当然，还有其他很多参数，有兴趣的话可以 点这里。 比如我就增加了这个全屏遮罩的参数。 1distractionFreeMode: true, 创建 Github ApplicationGitalk 需要一个 Github Application，点击这里申请。 填写下面参数： 点击创建 获取 Client ID 和 Client Secret 填入你的我们 Gitalk 参数中 当你参数都设置好，将代码推送到 Github 仓库后，没什么问题的话，当你点击进入你的博客页面后就会出现评论框了。 当你用 github 帐号登录（管理员），并且第一次加载该会比较慢，因为第一次加载会自动在你 repo 的仓库下创建对应 issue。 比如说这样： 当然，你也可以手动创建issue作为 gitalk评论容器。只要有 Gitalk 标签 和 id 对应标签就可以。比我我自己创建的 About issue 。 结语最后说几句吐嘈几句， Gitalk 需要你点开每篇文章的页面才会创建对应的 issue,对我来说真是个糟糕的体验（文章有点多~）。 当然，也有解决办法，这篇 自动初始化 Gitalk 和 Gitment 评论，就解决了这个问题。 最后，给个 star 吧~]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「体能训练理论」之金字塔]]></title>
    <url>%2F2017%2F07%2F10%2F%E3%80%8C%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA%E3%80%8D%E4%B9%8B%E9%87%91%E5%AD%97%E5%A1%94%2F</url>
    <content type="text"><![CDATA[引言体能，人体基础运动能力的统称，人体的本质属性，它支撑着日常生活工作的需要，也支撑着运动技战术的表现。 体能思路，是指导我们设计实施体能训练的思维方式，分析逻辑。它包括回归原点的 五大运动素质 &amp; 动力链理论，也包括在过程中引领方向的 功能性原则 和 金字塔 。 金字塔体能训练是一门实践科学，实践先于理论，而理论印证实践。体能训练有四大基础学科，分别是运动解剖学、运动生理学、运动生物力学和运动训练学。 五大运动素质对应生理学和运动训练学；动力链对应解剖学和运动生物力学；功能性对应着生理和生物力。而金字塔则对应了它们全部！或者说金字塔其实是诸学科在体能训练中的交汇，它囊括了所有之前的理论，并且赋予了更深层的意义。 金字塔代表了人体运动能力发展的客观规律，它是一个流程的引领，思维的分级，以及训练阶段的划分。 这里包括 关节功能+核心控制、基础动作模式、基础力量、综合体能、专项运动。他们在逻辑上互为基础和进阶，关节是动作的基础，动作承载力量，力量支撑各个运动素质，而专项是各个运动素质在具体运动中的表现。 也许这么说可能不能够让大家有清晰的认识，那么接下来我就把每层的内容和它们之间的逻辑关系简单的跟大家分享一下。 99%的运动者都是基础不足，上层过度。我们从基础开始，从下往上说起。 运动基础（关节功能 + 核心控制）运动基础主要内容包括 关节功能 和 核心控制 能力。 人体的关节功能有两个属性，一个是灵活性，一个是稳定性。举例来说，很多人由于长期缺乏锻炼，肩关节灵活性缺失，第一次学习竖直上举时，怎么努力都举不到头顶，显然应该先改善肩关节灵活性。再比如，膝关节的结构导致它只能进行屈伸的运动，所以我们要保证运动过程中不出现膝内扣，膝外翻的现象，也就是膝关节需要具备的稳定能力。在健身之前我们，应该先评估我们的关节功能。 运动基础中的第二部分内容就是核心控制能力。很多健身者入门者都会觉得核心是腹肌，觉得练核心的目的是拥有一个好看的腹肌。实际上，腹肌只是核心的一部分，核心是指一个区域，我们的整个躯干都属于核心区域。 运动的外在表现虽来源于四肢，比如跑步时你的四肢在运动，但是一个出色的外在运动表现是建立在稳定的核心基础之上的。如果躯干不稳定，在跑步的过程中整个脊柱很松散，甩来甩去，这样是很难提高跑步速度的。所以在学习动作之前，应该先加强核心控制能力。 所以我们会推荐没有进行过抗阻训练、长期久坐的同学先去练习一段时间的瑜伽和普拉提，瑜伽可以很好地改善关节灵活性，进而提高身体的柔韧性；而普拉提能提高的核心控制能力，并提高关节稳定性。一个合格的健身训练者，应该了解不同的训练体系，他要知道自身还缺乏什么，然后向不同的训练体系去借鉴，以提高自己。 基础动作模式什么是基础动作模式？简单地说就是，所有动作肢体特有的运动程序。人体就这么些零件，所以很多的动作之间都存在着些许的共性，我们将这些共性提炼出来并进行功能上的抽象，那么就形成了我们现在所要说的基础动作模式——双腿蹲、单腿蹲、推、拉、旋转、屈髋。 蹲：分为单腿蹲、双腿蹲。对应的训练动作有剪蹲和深蹲。 推：分为水平推、竖直推。对应的训练动作是卧推和实力举。 拉：分为竖直拉、水平拉。竖直拉包括引体向上、高位下拉，水平拉包括弹力带划船等等。 屈髋：最具代表性的动作就是硬拉。 旋转：动作比较复杂，在训练当中比较少出现，适合比较资深的训练者，比如说劈和砍，比如下劈球，比如拿锤子砸轮胎。前期不建议做，当你有一定训练水平的时候再去做旋转类动作。 基础动作模式的意义是什么？ 教会我们如何正确的使用我们的身体 评估你的是否存在关节功能缺陷 基于基础动作模式的学习意义和诊断意义，我们对待健身者或者需要进行体能训练的人很多时候都从这里开始。如果诊断结果良好，那么我们学习动作之后就可以上升到基础力量训练，如果诊断出关节功能缺陷，我们就要进行针对性的解决。 基础力量（肌肉力量）力量是所有运动素质的基础，如果你没有足够的力量，很多事情都很难完成。你想学习倒立，如果上肢力量足够，只需要了解动作技巧和细节，可能半个小时就能学会倒立。但是如果力量水平很低，就算把各种技巧和细节都学会了，也没有力气把自身撑起来，更不可能完成倒立。日常生活中，力量水平不足经常会成为我们突破运动瓶颈的障碍，有足够的力量才能跑得更快、跑得更远、跳得更高。所以，力量是所有运动素质的基础。 因此，在金字塔的这层，我们就要从徒手训练的阶段进阶到自由力量训练的阶段。负重和徒手的训练效果差异非常大，它不仅仅在于力量的提高，在重心控制、身体平衡、协调性控制等方面的区别也很大。力量训练能让身体各项能力同时提高，只有真正进入力量训练阶段（对于健身来说），才可以说真正踏上健身入门之路。 训练目标（综合体能和专项体能）最后，我们来到了金字塔的顶端，这就是我们的最终追求。 综合体能在此指的是体能所包含的五大运动素质——力量，速度，灵敏，耐力，柔韧。对于有专项运动需求的人，我们需要有针对性的重点发展这五大运功素质中的某几个。 当我们身体各关节灵活性和稳定性都可以满足要求，且核心控制能力也很强的情况下，又在标准动作的基础上储备了足够的肌肉力量，那么，不管你的目标是减肥，增肌，或者是进行某一个竞技性运动项目，你都可以相对安全且轻松地达成你的目标。 一般我们把还处在第一第二层的健身者称为健身入门者。不管你是刚刚走进健身房的新手，还是健身多年的老司机，都可以根据这个健身发展流程来审视自己目前的训练处在哪一个阶段。 总结体能训练金字塔告诉我们，体能训练要从关节功能和核心控制开始训练，通过六大基础运动模式的训练增强身体基础力量，只有基础力量够了，我们才能真正开始我们的训练目标，根据我们训练的项目增强专项体能，比如拳击，我们要增强力量，耐力，灵敏。 清楚了这个体能训练金字塔之后，更重要的事还是要去执行。执行层面会涉及更多技术问题，也就是我们常说的如何做标准的动作，如何制定适合自己的训练计划等等。 健身是一项系统性工程，愿每一个人都能找到方法，科学有效地塑造自己的身体。 参考 《体能训练之金字塔》 零基础健身者的运动发展流程]]></content>
      <tags>
        <tag>生活</tag>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「体能训练理论」之动力链]]></title>
    <url>%2F2017%2F07%2F10%2F%E3%80%8C%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA%E3%80%8D%E4%B9%8B%E5%8A%A8%E5%8A%9B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[引言与其说体能训练是一种行为，不如说体能训练是一种程序。只要符合逻辑，就可以自由组合。 那么体能训练的逻辑是什么？我们将之总结为：动力链、功能性、金字塔。 动力链如果说 五大运动素质（力量、速度、耐力、灵敏、柔韧）代表了体能的宏观表现，那么动力链理论则阐释了人体解剖结构在运动中的客观规律，这二者同为人体的本质属性。 动力链这一理论早在1875年就被提出过，当时的定义还很简单，就是指几个相邻的关节所组成的复杂动作单元。后来在不断地实践与研究中，动力链理论也不断的升级，越来越清晰，越来越客观，也越来越复杂，并且逐渐成为了体能训练师们必备的思考工具之一。 来看看动力链的英文解释: The concept of the kinetic chain originated in 1875, when a mechanical engineer named Franz Reuleaux proposed that if a series of overlapping segments were connected via pin joints, these interlocking joints would create a system that would allow the movement of one joint to affect the movement of another joint within the kinetic link. Dr. Arthur Steindler adapted this theory in 1955, and included an analysis of human movement. Steindler suggested that the extremities be viewed as a series of rigid, overlapping segments and defined the kinetic chain as a “combination of several successively arranged joints constituting a complex motor unit.” The movements that occur within these segments present as two primary types—open and closed. 这种模糊形容根本无法让人们理解它真正的内核，虽然它看起来就像是一堆联动的齿轮和杠杆。实际上它也真的很像一堆齿轮和杠杆，有的负责驱动，有的负责传力，有的负责稳定。 为了方便大家理解，下面我要将这个理论拆解开来跟大家分享。 首先，我们需要从以上的定义中提炼出来一些关键词，比如说 “运动”、“几个”、“相邻”等等。那么这几个词分别代表了什么？ 我们讨论问题的角度是运动的； 我们需要考虑的人体解剖结构问题； 我们需要考虑相邻关节的协作关系； 我们需要分析每一个关节的使用特点。 所以，它似乎并不能被完美的定义，而是只可意会不可言传。 那么关于动力链，我们需要掌握两个最基本的知识：动力链模型、开链与闭链。 动力链模型在动力链理论中，我们考虑运动的最小单位是关节，诸多关节运动的协作产生了整体上的复杂动作。所以每一个关节的功能就决定了整体动作的表现，任何一个关节功能受限都会导致整体动作的失衡。 而我们所指的关节功能，可以从生物力学角度简单的概括为： 灵活(M,Mobility) 稳定(S,Stability) 但看起来简单的两个词，其实意义非常。 什么是灵活？ 很多人的第一反应就是能自由的运动呗~然后部分专业人士可能会想到活动度。但是你的关节如果仅仅具备很好的活动度就能够胜任运动中的需求么？显然是不能的。所以灵活的意义远不止关节活动度，关节活动度仅仅是灵活的基础，而更重要的还有产力的能力。没错，这里的灵活既包括关节主被动活动范围，也包括产力的能力，比如产力的大小，产力的快慢等等。 举个例子：小明的髋关节活动范围非常好，能竖叉能横叉，但是臀大肌并没有很好的力量，所以不能够支撑你的跑步与跳跃，所以此时的髋关节灵活性仍然是不足的，只不过这里强调的是力量的缺失。 什么是稳定？ 稳定就是稳定呗~就是待着不动呗~就是牢固呗~灵活还能说出个关节活动度，而稳定的定义真的让很多人摸不到头脑，因为似乎“稳定”一词已经很好地形容了关节的功能表现。但是实际上我们仍然可以对其进行深究，并且这样做是有意义的，因为表现的不同直接影响训练的手段。 如果我们把“稳定”定义为是一种提供安全性的保护，那么我们就可以假想出两个现象： 一个非常贵重的瓷器抱在手中，我不能把它摔碎，所以我抱着不动~ 同样是这个非常贵重的瓷器抱在手中，我不能把它摔碎，但是我可以慢慢的把它放在地上。同样是保护瓷器不被摔碎，但是却有两个表现，一个是hold住，另外一个是慢慢的放在地上，一个不动，一个动。所以我们人体关节的稳定也是如此，既包括保持身体姿态，关节位置的相对固定，也包括有控制的缓冲外力，退让做功。 举个例子：我们的核心区域在运动中应该尽可能的保持姿态的稳定，所以是抱着瓷器不动；我们的膝关节在走路与跑步中从伸到屈，缓冲脚落地产生的冲击力，所以是抱着瓷器往下放。 在了解了 SM (稳定和灵活)的意义之后，更重要的是明白：这两种并不会孤立的存在，而是相辅相成同时存在的，只不过在人体整体动力链中体现的侧重点不一样，在肢体的协同运动中扮演的角色不一样。比如对于核心区域来说，灵活恰是其稳定的基础，因为不同体位下脊柱的排列形式直接影响稳定的表现。 当 SM 代表了关节功能之后，在人体的整体运动结构中，不同的关节所凸显出来的功能是不同的，并且它们遵循一定的逻辑分布。 从下往上说： 足弓——稳定 第一个缓冲冲击力的关节，并且没有多大的关节活动度。 足踝——灵活 “足” “踝”形成了一个稳定与灵活兼备的整体，但是在运动中它是下肢蹬伸最后一个主动发力的关节，并且无时无刻不在调整着身体与地面之间的位置关系，所以在这里我们更强调它的灵活性。 膝关节——稳定 强大的承重关节，且仅存在屈伸的动作（屈膝位的内外旋的意义是提供可控的缓冲空间，并非叫你主动旋转），更重要的是，无论走路、跑步、跳跃，膝关节都是非常重要的离心缓冲关节。 髋关节——灵活 强大的发力关节，而且活动范围也非常广泛，它引领着下肢的动作产生。但是由于位置与功能的特殊，所以其稳定性也相当重要，直接可以影响核心的稳定结构，特别是在闭链状态下。 腰椎——稳定 相对的绝对稳定体。所谓绝对，是因为腰椎所处的位置恰好为核心地带，这里的功能是维持姿态以及为上下肢的运动提供稳定基础，所以要“抱着缸不动”。而所谓相对，是因为不同的体位下腰椎的姿态是需要随之调整的，并不能以不变应万变。 胸椎——灵活 胸椎的灵活性其实并不好，但是相比于腰椎来说就好太多了，特别是在旋转动作上。在旋转鞭打的动作模式中，胸椎是继下肢产力之后的第一个角速度放大的关节，其灵活程度直接影响了上肢的鞭打效果。当然，在更多的时候胸椎要参与承重，但即便承重，也是以其良好的灵活性为基础的，比如说手臂上举过头负重的动作。 颈椎——稳定 虽然很灵活，但却需要很稳定！因为头部的位置变化会直接改变身体肌张力的大小分布，这个不仅可以让我们身体姿态发生变化，还会破坏掉本体感觉的准确性。当然，这也是猫在空中可以转体的原因，以及为什么我们打拳的时候不能回头。 肩胛胸关节——稳定 这是一个很奇葩的关节，从动力链结构上看，它是稳定关节，但稳定的并不是它自己，而是肩关节。在实际运动中，肩胛胸关节和肩关节是联动运动的，而且前者为后者提供稳定性，是后者得以安全展现灵活的基础。但是这个“稳定”恰恰是通过肩胛胸关节本身的灵活性来展现的，比如手臂上举时的上回旋。 肩关节——灵活 没的说，人体最灵活的关节，也是人体最不稳定的关节，其球窝关节的解剖结构已经说明了一切。 肘关节——稳定 结构上跟膝关节相对，但是实际上要比膝关节灵活的多。所以如果进化论成立的话，人类从四脚着地变成双脚着地的过程，使我们的下肢关节趋向于稳定，上肢关节趋向于灵活。而这正与 “开链”或者“闭链”的需求相适应。 开链&amp;闭链我们的关节同时存在S与M，而在整体的运动中有不同的体现，甚至于同样是S或者M的上下肢关节却存在了显著的差别。那么在此我们需要引出一个新的概念：开链 &amp; 闭链。 开链 开链，简单地说就是我们身体产生力量，改变了外界物体的运动状态。比如说哑铃二头弯举，投掷，摘苹果等动作都是开链动作。我们可以认为我们的身体在对抗趋于无穷小的阻力，那么我们就可以随意改变物体的运动状态，随便摆弄它，所以此时我们的肢体的灵活性就可以充分的发挥。比如我们的上肢就是以开链运动为主的，所以它整体表现出更好的灵活性。 闭链 闭链，简单的说就是我们的身体产生力量，却没能推动外界的物体，反而改变了我们自身的运动状态。比如说跑步与深蹲，我们扒地，我们蹬地，并没有让地板产生位移，我们自己却向前或者向上运动了。所以我们可以认为闭链运动时，我们的身体在对抗趋于无穷大的阻力，我们根本不可能改变它，所以只能运动我们自己。而在面对这样无穷大的阻力的时候，我们需要将我们的关节摆在力学结构最优的位置上才能发挥我们自身的最大经济性和效率，而且在这个状态下，各个关节的位置直接影响了身体的整体姿态和状态，所以灵活性被抑制。我们的下肢，最擅长、做的最多的就是闭链运动，所以它更加的趋于稳定。 开链和闭链直接影响我们的训练适应，因为它们所表现的力学结构是不同的。 总结了解动力链并不是让我们装逼的，而是让我们更加了解人体的客观规律来指导训练的。 它是一个非常好的思考工具。比如我们在训练下肢力量的时候，我们就需要考虑髋关节灵活性对于下肢力量表现的影响，于是乎我们可能更加重点强化髋的产力能力。但是当考虑到屈髋动作时，也许实际中更多的是开链的屈髋，所以我们就能以此为依据来选择髂腰肌和股直肌的训练动作。 除此之外，每个关节本身的功能完整性是非常重要的，如果一个关节有功能缺陷，那么在整体运动中它就不能够尽到它的职责，所以一定会有另外一个或者几个关节来代偿它的功能，那么就相当于一个3人的团队，一个请假了，另外两个就得加班。如果一次两次没关系，它要是请了一年的产假，那么另外俩人可能会由于长期超负荷工作而积劳成疾。当然，对于公司来说我可以再雇人，但是我们的人体可没有能再多长一个关节之说。 所以其实很多跑步膝的问题恰是由于髋和踝的功能缺陷而导致的。 最后我要再次强调：任何一个关节，稳定与灵活同时存在，只不过体现的程度和侧重不同。在动力链中，灵活的关节不代表没有稳定，更不代表稳定不重要；稳定的关节也需要灵活，而且灵活可能是稳定的基础。 了解了动力链，你会更懂运动中的人体，也许你有了思考问题的方向，但仍然缺少方法，所以你还需要具备「功能性」的思维方式。 转自 《体能训练之动力链》]]></content>
      <tags>
        <tag>生活</tag>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「体能训练理论」之功能性]]></title>
    <url>%2F2017%2F07%2F10%2F%E3%80%8C%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83%E7%90%86%E8%AE%BA%E3%80%8D%E4%B9%8B%E5%8A%9F%E8%83%BD%E6%80%A7%2F</url>
    <content type="text"><![CDATA[引言体能训练是一种开源的程序它所依仗的并不是固有的方法手段，而是能够贯穿始终的逻辑，它是一种指导实践的思维方式，我们管它叫“体能思路”。 体能思路有两个方向，一个是原点，一个是过程。所谓原点我们认为是人体的本质属性，比如之前我们分享的五大运动素质以及动力链理论。所谓过程是我们分析问题实现目的的思考方向以及逻辑，它主要体现在接下来要跟大家分享的功能性原则和金字塔。 今天先来说功能性原则。 功能性我们所说的功能性是一种解决问题的思维方式，而功能性训练则定义了一种多关节参与，多平面运动的复杂练习。功能性训练是具体的，比较好理解，我就不赘述了，也不评价其优劣，因为在“功能性”的思维方式下，只存在目标之下的合适与否。 什么是功能性？我们把它定义为目标导向下的效率，所以它是一种程度的体现。如果一个练习与目标的相关性强，那么我们认为它具备较强的功能意义；而如果一个练习与它的目标背道而驰，那么我们就认为它缺乏功能意义。 举个例子，对于偏瘫患者来说，一个手指的屈伸就已经具备非常强的功能意义了，而对于一个马拉松爱好者来说，静蹲的价值可能并不是想象中那么高。 一般来说，在思考功能性问题的时候我习惯从以下三个方面入手：肌肉的生理适应 、动作模式 和 专项需求。 1. 肌肉的生理适应其实练肌肉谁都会，是一个相对好入手的技能，但是当你给这个行为赋予体能训练使命的时候就需要思考一些问题，比如说你现在练习所发展的东东真的是你实际运动中所需要的东东么？ 我们都知道肌肉的生理收缩模式可以简单的分为向心收缩，离心收缩和静力收缩。现在的研究表明，这三种收缩模式的练习所产生的适应性提高存在显著的特异性。也就是说我向心练习所发展的能力只在向心运动中表现最好，在离心和静力中都不佳。同样，离心收缩也只能获得最好的离心能力收益。而静力就更变态，其训练最佳效果仅仅体现在所锻炼的关节角度下，换一个角度能够迁移的效果有可能都不到一半儿。这样看来，你的训练是不是并没有达到你想要的效果呢？ 举个例子： 为什么静蹲对于跑步爱好者来说可能并没有那么理想？因为膝关节股四头肌在跑步中以离心缓冲为主，而且角度在伸膝末端的30°左右，而静蹲却是在屈曲90°左右的角度下呆着不动……着不动……不动……动…… 除此之外，需要考虑的问题还很多，比如说发力模式，是加速？减速？还是匀速？再比如关节活动角度上发力点的位置，是伸展末端发力？屈曲极限发力？还是在屈伸过程中的某一点发力？阻力加在哪里，就会在哪里产生最好的适应，那么功能的意义就体现在这里。 2. 动作模式动作模式是动作程序的体现，而基础动作模式是诸多复杂动作模式共性的抽象体现，并且基础动作模式一定是符合解剖结构和生物力学特点的，说白了也就是我们人体被设计来应该完成的动作。 如果说大多数运动都可以认为是基础动作模式的升级与排列组合，同时基础动作模式本身又能衍生出来很多训练动作，那么选择和实际运动相对应的练习就是另一个功能性的体现了。 比如说发展起跳能力，因为跳是蹲的升级，所以我一定首选深蹲练习；再比如说跑步，存在大量的下肢摆动与支撑的交替，摆动可以认为是下肢开链屈髋与蹬伸，而支撑可以认为是下肢单腿蹲的一瞬间，那么我会选择箱式单腿蹲，保加利亚蹲，悬垂屈髋等等；再再比如，拳击是基于“旋转”加“上肢推”加“单腿蹲”的动作模式，那么我就要练习剪蹲…旋转…单臂…推举…吗？ 其实动作模式的选择要结合动力链一起去思考，这里除了要思考开链还是闭链之外，还要考虑动力链的完整性以及发力的顺序或者说是力学结构。说到上肢推的动作模式，水平推的话我相信很多人都会想到卧推和俯卧撑，那么这两个动作的功能性如何评价呢？ 卧推，一个挺奇葩的动作，奇葩在哪呢？来，咱们数数卧推的主动关节都有哪些：肩关节，肘关节。那么我们上肢链在上肢推动作模式下参与的关节都有哪些呢？肩关节，肘关节！就这些么？再想想！其实你还疏漏了一个非常重要的关节——肩胛胸关节！几乎所有上肢的动作都以肩胛胸关节的运动为基础，而卧推却并没有，特别是标准的卧推~ 俯卧撑，虽然肩胛胸，肩关节，肘关节全面参与到运动中去，但不巧的是它是一个闭链运动，而实际运动中我们的上肢会以开链为主！呵呵~ 别着急，认真你就输了！上面两段其实是个伪命题，我这么做主要是想通过这个平易近人的例子来帮助大家掌握的分析问题的思路！如果你需要发展上肢最大力量表现，那么显然卧推是你的首选。而如果你要优化上肢的力学结构，特别是水平推的发力顺序，那么俯卧撑是你首选。再如果你要提高上肢的延展性以及伴随旋转的加速能力，那么单臂水平推的练习给你的帮助最大！ 所以，选择什么，看目标喽~ 3. 专项需求其实这个非常好理解，也是功能性原则的根本目的，但是为了和上面两个方向区分开，这里主要针对的是不同的运动素质需求。 Q：对一个英超的后卫进行长距离高强度的游泳练习是否具备功能性意义？！ A：具备！ Q：为什么？ A：因为他喜欢游泳，这个可以让他心情愉悦然后更好的训练和比赛！ 咳咳！当然，这样的答案是合情合理的！但是我们不妨换一个角度去分析。 英超，几乎是足球联赛中对抗最强的，他们的后卫每场比赛动不动就跑个8千1万的，而这8千1万真心不是慢慢悠悠颠儿下来的，而是各种加速减速变向拼抢，所以其强度非常之大。那么这就需要很好的心肺系统功能，一方面体现在有氧与无氧耐力上，另一方面呼吸器官的机能上。游泳练习，不仅可以提高有氧以及无氧耐力，其水环境还可以给胸扩张带来阻力，直接锻炼了呼吸肌的收缩能力。另外，水环境真的能够给人们带来愉悦的感觉，特别是水流水压给肌肉和筋膜的按摩效果，真的是一举两得的“功能性”训练。 还有，你以为篮球运动员的拳击练习真的只是给枯燥乏味的体能训练增加一点乐趣么？并不是！ 1. 拳击可以在发生场内冲突的时候很好地保护自己； 2. 拳击运动可以强化旋转动作模式下的速度、稳定、和准确性； 3. 拳击是手脚高度协调的运动，对于发展手脚搭配的动作灵敏有神奇的效果。 而这些不就是一名篮球运动员所需要的么？！ 总结所以，功能性原则，解决的是“为什么练（for！not why）以及 练什么”的问题！ 如果我们是简单活动活动身体那就算了，但如果我们要进行一个有针对性的体能训练，那么请琢磨琢磨你选择的动作是否合理，是否能够满足你的专项需求！ 所以，招财猫式弹力带抗阻外旋真的是练习肩袖首推的动作么？ 所以，蚌式练习和dirty dog真的是发展髋外旋外展能力最好的练习么？ 所以，仰卧卷腹发展出来的腹直肌是好看呢？还是好用呢？ 所以，我们真的要来一次大清洗，摒弃掉我们以前那些练习么？ 当然不要！每一个动作都有它存在的意义，都有它的价值所在！有可能这个动作和你要发展的能力不直接相关，但是它可能是你进行“功能性”训练的基础，你不得不去做它！ 所以，训练的逻辑很重要！ 转自《体能训练之功能性》]]></content>
      <tags>
        <tag>生活</tag>
        <tag>健身</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods私有仓库的创建]]></title>
    <url>%2F2017%2F03%2F10%2FCocoaPods%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文发布于 BY Blog、简书 转载请保留链接 上一篇文章 《CocoaPods公有仓库的创建》 前言最近参照了网上一大堆 CocoaPods私有仓库 的教程，按教程操作得到的pod仓库里面是这样的~ 代码和版本描述居然混在了一起，简直太糟糕~ 虽然也能用，但是和CocoaPods本身的结构设计就不相符。 在上一篇《CocoaPods公有仓库的创建》中我们了解到，master 目录中只存放 代码库 的描述文件，而不是存放代码。就像这样 代码我们另外存放在代码仓库中 很多人不了解CocoaPods的工作原理就复制粘贴别人的教程来做教程~ 吐槽结束，进入正文 正文创建版本库(repo)首先，创建一个像 master 一样的存放版本描述文件的git仓库，因为是私人git仓库，我们选择 oschina 创建远程私有仓库（因为是免费的）或者也可以在GitHub上创建（$7/month）。 下面以 oschina 为例 创建版本描述仓库 回到终端，将这个远程的私有版本仓库添加到本地，repo 就是 repository 储存库的缩写。 $ pod repo add MyRepo https://git.oschina.net/baiyingqiu/MyRepo.git 查看在 Finder 目录 ~/.cocoapods/repos， 可以发现增加了一个 MyRepo 的储存库 创建代码库回到 oschina 创建私人代码库 创建时添加 MIT License 和 README 将仓库克隆到本地，添加你的代码文件、仓库名.podspec 描述文件，还有.swift-version. 如下 .swift-version文件用来知道swift版本，用命令行创建 $ echo &quot;3.0&quot; &gt; .swift-version .podspec 文件是你这个代码库的pod描述文件,可以通过pod指令创建空白模板： $ pod spec create MyAdditions 或者 强烈建议 直接拷贝下面的模板进行修改 12345678910111213141516171819Pod::Spec.new do |s| s.name = "MyAdditions" # 项目名称 s.version = "0.0.1" # 版本号 与 你仓库的 标签号 对应 s.license = "MIT" # 开源证书 s.summary = "私人pod代码" # 项目简介 s.homepage = "https://git.oschina.net/baiyingqiu/MyAdditions" # 仓库的主页 s.source = &#123; :git =&gt; "https://git.oschina.net/baiyingqiu/MyAdditions.git", :tag =&gt; "#&#123;s.version&#125;" &#125;#你的仓库地址，不能用SSH地址 s.source_files = "MyAdditions/*.&#123;h,m&#125;" # 你代码的位置， BYPhoneNumTF/*.&#123;h,m&#125; 表示 BYPhoneNumTF 文件夹下所有的.h和.m文件 s.requires_arc = true # 是否启用ARC s.platform = :ios, "7.0" #平台及支持的最低版本 # s.frameworks = "UIKit", "Foundation" #支持的框架 # s.dependency = "AFNetworking" # 依赖库 # User s.author = &#123; "BY" =&gt; "qiubaiyingios@163.com" &#125; # 作者信息 s.social_media_url = "http://qiubaiying.github.io" # 个人主页end 这里我要说一下一个坑，用 oschina 创建私人仓库时, 在验证时可能会找不到 MIT LICENSE证书,将其中的 s.license = &quot;MIT&quot; 修改为，指定文件 s.license = { :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; } 然后开始验证我们的仓库配置是否正确，并按照要求进行修改 $ pod lib lint 一般出现错误警告，需要添加 --private 或者 --allow-warnings，就可以通过验证 $ pod lib lint --private 验证成功后出现 -&gt; MyAdditions (0.0.1) MyAdditions passed validation. 将描述文件推送到版本库将项目打上标签推到远程仓库，标签号 和 版本号对应 都是0.0.1 最后将我们的代码仓库的描述信息，push 到我们的版本仓库中 $ pod repo push MyRepo MyAdditions.podspec 这时会对远程仓库进行验证，成功的话就会在 ~/.cocoapods/repos/MyRep中发现新增的仓库描述信息了 若是出现错误信息 [!] The repo `MyRepo` at `../.cocoapods/repos/MyRepo` is not clean 更新下我们的版本库， $ pod repo update MyRepo 再继续上传即可。 pod repo push MyRepo MyAdditions.podspec 的过程就是 验证 MyAdditions.podspec 文件 拉取远程版本库 MyRepo 添加 MyAdditions.podspec 到版本库中 push 到远程 添加完成后我们就可以在pod中搜索 $ pod search MyAdditions -&gt; MyAdditions (0.0.1) Some category of the framework and UIKit pod &apos;MyAdditions&apos;, &apos;~&gt; 0.0.1&apos; - Homepage: https://git.oschina.net/baiyingqiu/MyAdditions - Source: https://git.oschina.net/baiyingqiu/MyAdditions.git - Versions: 0.0.1 [MyRepo repo] (END) 私人pod库的使用使用私人pod库的需要在Podflie中添加这句话，指明你的版本库地址。 source ‘https://git.oschina.net/baiyingqiu/MyRepo.git’ 注意是版本库的地址，而不是代码库的地址，很多教程都把我搞晕了~ 若有还使用了公有的pod库，需要把公有库地址也带上 source ‘https://github.com/CocoaPods/Specs.git’ 最后的Podflie文件变成这个样子 source ‘https://github.com/CocoaPods/Specs.git’ source ‘https://git.oschina.net/baiyingqiu/MyRepo.git’ platform :ios, &apos;8.0&apos; target ‘MyPodTest’ do use_frameworks! pod “BYPhoneNumTF” #公有库 pod ‘MyAdditions’ #我们的私有库 pod ‘BYAdditions’ #这是我又添加到版本库中的另一个代码库 end 测试： $ pod install 加载完成可以看到代码已经整合到我们的项目中了 perfect！ 回到Fender中 ~/.cocoapods/repos,会发现 repos 中增加了一个pod版本库。 执行 pod install 命令时 会拉取远程 Podflie 中 source 标记 版本库 到本地的 repos 文件夹中 在 版本库 中搜索我们pod ‘MyAdditions’ 的 MyAdditions.podspec 文件。 根据 MyAdditions.podspec 文件中描述的源码地址下载并整合到项目中 结语通过 《CocoaPods私有仓库的创建》 和 《CocoaPods公有仓库的创建》这两篇文章，相信大家对CocoaPods的工作原理都有了更深层次的了解。 在写博客和和创建的过程中，踩了不少的坑（😀前人教程留下的），很多的东西只有自己操作完才能真正的领会。 最后，如果本文有什么错误或者有什么不同的观点欢迎提出交流。😉]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Git</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods公有仓库的创建]]></title>
    <url>%2F2017%2F03%2F08%2FCocoaPods%E5%85%AC%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文发布于 BY Blog、简书 转载请保留链接 前言作为iOS开发者，CocoaPods的使用为我们开发带来了极大的便利。 我们先来看看CocoaPods本地目录中有什么 $ cd ~/.cocoapods/repos/master 或者显示隐藏文件 $ defaults write com.apple.finder AppleShowAllFiles -boolean true ; killall Finder 然后进入 ~/.cocoapods/repos/master 你会发现 master 是一个 git 仓库，输出仓库的远程地址，发现是一个GitHub仓库 $ git remote -v origin https://github.com/CocoaPods/Specs.git (fetch) origin https://github.com/CocoaPods/Specs.git (push) 继续，我们进入Specs文件夹一直往里点 你会发现很多框架以及版本号，选择一个框架，通过 $ pod search YYImage pod搜索 Specs 文件夹中的框架，输出框架信息 -&gt; YYImage (1.0.4) Image framework for iOS to display/encode/decode animated WebP, APNG, GIF, and more. pod &apos;YYImage&apos;, &apos;~&gt; 1.0.4&apos; - Homepage: https://github.com/ibireme/YYImage - Source: https://github.com/ibireme/YYImage.git - Versions: 1.0.4, 1.0.3, 1.0.2, 1.0.1, 1.0, 0.9.5, 0.9.4, 0.9.3, 0.9.2, 0.9.1, 0.9.0, 0.8.9 [master repo] - Subspecs: - YYImage/Core (1.0.4) - YYImage/WebP (1.0.4) 每个版本号对应的一个json文件,描述了每个对应版本的框架的信息、配置、及源码下载地。 我们在 CocoaPods 发布我们的框架时，就是要在 master 仓库中添加我们的仓库描述信息，然后push到远程仓库中。不过这个过程不用我们手动去操作，只需要通过pod命令进行操作即可。 下面我们将一步步把我封装的这个简单的TextFiled控件 BYPhoneNumTF 上传到 Cocoapods 公有仓库中。 正文注册 CocoaPods 账号想创建开源的Pod库，就要注册一个CocoaPods账号，我们使用终端注册, email 用你的 GitHub 邮箱 $ pod trunk register GitHub_email &apos;user_name&apos; --verbose 等终端出现下面文字，CocoaPods 会发一个确认邮件到你的邮箱上，登录你的邮箱进行确认。 [!] Please verify the session by clicking the link in the verification email that has been sent to you_email@163.com 注册成功！ 确认后再终端输入 pod trunk me 可以看到你的注册信息 创建Git仓库在 GitHub 上创建一个公开项目，项目中必须包含这几个文件 LICENSE:开源许可证 README.md:仓库说明 你的代码 BYPhoneNumTF.podspec: CocoaPods 的描述文件，这个文件非常重要 如下图： BYPhoneNumTF 文件夹下是我存放代码的地方 BYPhoneNumTF_Demo 是代码使用样例（不是必须的） 创建.podspec.podspec 是用 Ruby 的配置文件，描述你项目的信息。 在你的仓库目录下，使用终端命令创建 $ pod spec create BYPhoneNumTF 这时就会在你的仓库下生成 BYPhoneNumTF.podspec 文件 修改里面的配置就可以发布了~当然，没这么简单。 配置文件中的注释很多，而且很多配置都不是必须的，写多了等下验证还不让过~ so~强烈建议，直接拷贝下面的主要配置进行修改 12345678910111213141516171819Pod::Spec.new do |s| s.name = "BYPhoneNumTF" # 项目名称 s.version = "1.0.0" # 版本号 与 你仓库的 标签号 对应 s.license = "MIT" # 开源证书 s.summary = "A delightful TextField of PhoneNumber" # 项目简介 s.homepage = "https://github.com/qiubaiying/BYPhoneNumTF" # 你的主页 s.source = &#123; :git =&gt; "https://github.com/qiubaiying/BYPhoneNumTF.git", :tag =&gt; "#&#123;s.version&#125;" &#125;#你的仓库地址，不能用SSH地址 s.source_files = "BYPhoneNumTF/*.&#123;h,m&#125;" # 你代码的位置， BYPhoneNumTF/*.&#123;h,m&#125; 表示 BYPhoneNumTF 文件夹下所有的.h和.m文件 s.requires_arc = true # 是否启用ARC s.platform = :ios, "7.0" #平台及支持的最低版本 s.frameworks = "UIKit", "Foundation" #支持的框架 # s.dependency = "AFNetworking" # 依赖库 # User s.author = &#123; "BY" =&gt; "qiubaiyingios@163.com" &#125; # 作者信息 s.social_media_url = "http://qiubaiying.github.io" # 个人主页end 最最关键的步骤的到了，验证 .podspec 文件的格式是否正确， $ pod lib lint 验证会出现成功出现 -&gt; BYPhoneNumTF (1.0.0) BYPhoneNumTF passed validation. 但是很多情况没这么顺利，比如: -&gt; BYPhoneNumTF (1.0.0) - WARN | url: There was a problem validating the URL http://qiubaiying.github.io. [!] BYPhoneNumTF did not pass validation, due to 1 warning (but you can use `--allow-warnings` to ignore it) and all results apply only to public specs, but you can use `--private` to ignore them if linting the specification for a private pod. [!] The validator for Swift projects uses Swift 3.0 by default, if you are using a different version of swift you can use a `.swift-version` file to set the version for your Pod. For example to use Swift 2.3, run: `echo &quot;2.3&quot; &gt; .swift-version`. You can use the `--no-clean` option to inspect any issue. 提示我们需要加--allow-warnings这么一句话，命令改为 $ pod lib lint --allow-warnings 若还是提示什么&#39;echo &quot;2.3&quot; &gt; .swift-version&#39;的，就加这么一个东西。 $ echo &quot;2.3&quot; &gt; .swift-version 然后在进行验证，这是应该就可以了。若还是不行，回到配置文件中检查有没有写错配置信息~ 给仓库打标签验证成功后，将仓库提交到远程，然后给仓库打上标签并将标签也推送到远程。 标签相当于将你的仓库的一个压缩包，用于稳定存储当前版本。标签号与你在 s.version = &quot;1.0.0&quot;的版本号一致 1.0.0 创建标签 $ git tag -a 1.0.0 -m &apos;标签说明&apos; 推送到远程 $ git push origin --tags 发布.podspec最后一步，发布项目的描述的文件 BYPhoneNumTF.podspec 在仓库目录下执行 pod trunk push BYPhoneNumTF.podspec 将你的 BYPhoneNumTF.podspec 发布到公有的speecs上,这一步其实做了很多操作,包括 更新本地 pods 库 ~/.cocoaPods.repo/master 验证.podspec格式是否正确 将 .podspec 文件转成 JSON 格式 对 master 仓库 进行合并、提交.master仓库地址 成功后将会出现下列信息： Updating spec repo `master` Validating podspec -&gt; BYPhoneNumTF (1.0.0) Updating spec repo `master` -------------------------------------------------------------------------------- 🎉 Congrats 🚀 BYPhoneNumTF (1.0.0) successfully published 📅 March 7th, 01:39 🌎 https://cocoapods.org/pods/BYPhoneNumTF 👍 Tell your friends! 说明发布成功，你就可以通过上面的URL: https://cocoapods.org/pods/BYPhoneNumTF 进入的Pods查看自己的仓库信息了. 使用仓库发布到Cocoapods后，在终端更新本地pods仓库信息 $ pod setup 查询仓库 $ pod search BYPhoneNumTF -&gt; BYPhoneNumTF (1.0.0) A delightful TextField of PhoneNumber pod &apos;BYPhoneNumTF&apos;, &apos;~&gt; 1.0.0&apos; - Homepage: https://github.com/qiubaiying/BYPhoneNumTF - Source: https://github.com/qiubaiying/BYPhoneNumTF.git - Versions: 1.0.0, 0.0.1 [BYPhoneNumTF repo] (END) 若出现仓库信息说明已经成功了，这时候你就可以在 Podfile 添加、使用自己的仓库了 pod &#39;BYPhoneNumTF&#39;, &#39;~&gt; 1.0.0&#39; 更新维护当你的代码更新维护后，就需要重写发布，流程是： 更新BYPhoneNumTF.podspec中的版本号 打上标签推送远程 pod trunk push BYPhoneNumTF.podspec 推送到pods仓库 更新后你就可以在 CocoaPods Master Repo 仓库上看到自己的提交记录了。 结语到此,你已经掌握了创建和维护一个Cocoapods公有仓库的技能了，是不是很棒~]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>Git</tag>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件目录树状(tree)显示]]></title>
    <url>%2F2017%2F03%2F07%2F2017-3-07-%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%A0%91%E7%8A%B6-tree-%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[使用 tree 在终端显示树状文件结构 安装 tree使用 brew 进行安装 $ brew install tree 使用 直接使用 tree 命令，会在当前文件目录下，递归输出所有文件层级 $ tree 限制层级 $ tree -L 2 指定当前目录下的某个文件夹 $ tree Desktop 导出文件用&gt; 文件名.格式 的形式导出 $ tree -L 1 &gt; tree.md]]></content>
      <tags>
        <tag>开发技巧</tag>
        <tag>Mac</tag>
        <tag>效率</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 .gitignore 忽略 Git 仓库中的文件]]></title>
    <url>%2F2017%2F02%2F22%2F%E4%BD%BF%E7%94%A8-.gitignore-%E5%BF%BD%E7%95%A5-git-%E4%BB%93%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用 .gitignore 文件忽略指定文件 .gitignore在Git中，很多时候你只想将代码提交到仓库，而不是将当前文件目录下的文件全部提交到Git仓库中，例如在MacOS系统下面的.DS_Store文件，或者是Xocde的操作记录，又或者是pod库的中一大串的源代码。这种情况下使用.gitignore就能够在Git提交时自动忽略掉这些文件。 忽略的格式 # :此为注释 – 将被 Git 忽略 *.a :忽略所有 .a 结尾的文件 !lib.a : 不忽略 lib.a 文件 /TODO :仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODO build/ : 忽略 build/ 目录下的所有文件 doc/*.txt : 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt 创建方法从 github 上获取github上整理了一些常用需要的项目中需要忽略的文件配置，根据需要进行获取 https://github.com/github/gitignore.git 与 Xcode 相关的三个文件 Xcode.gitignore Objective-C.gitignore Swift.gitignore Xcode.gitignore忽略 Xcode 配置信息，如操作记录，默认打开窗口等 其他两个在 Xcode.gitignore 基础上针对不同的语言进行忽略 将这些文件重写命名为 .gittignore $ mv Swift.gitignore .gittignore 通过 gitignore.io 创建（推荐）先自定义终端命令：macOS下默认是\#!/bin/bash： $ echo &quot;function gi() { curl -L -s https://www.gitignore.io/api/\$@ ;}&quot; &gt;&gt; ~/.bash_profile &amp;&amp; source ~/.bash_profile 如果是 #!/bin/zsh $ echo &quot;function gi() { curl -L -s https://www.gitignore.io/api/\$@ ;}&quot; &gt;&gt; ~/.zshrc &amp;&amp; source ~/.zshrc 使用在当前终端目录下 $ gi swift &gt; .gitignore 就会针对 Swifit 类型的工程创建 .gitignore 文件。]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
        <tag>Git</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 代码回滚]]></title>
    <url>%2F2017%2F02%2F16%2FGit-%E4%BB%A3%E7%A0%81%E5%9B%9E%E6%BB%9A%2F</url>
    <content type="text"><![CDATA[并不适合阅读的个人文档。 git revert 和 git reset 的区别 先看图： sourceTree 中 revert 译为提交回滚，作用为忽略你指定的版本，然后提交一个新的版本。新的版本中已近删除了你所指定的版本。 reset 为 重置到这次提交，将内容重置到指定的版本。git reset 命令后面是需要加2种参数的：–-hard 和 –-soft。这条命令默认情况下是 -–soft。 执行上述命令时，这该条commit号之 后（时间作为参考点）的所有commit的修改都会退回到git缓冲区中。使用git status 命令可以在缓冲区中看到这些修改。而如果加上-–hard参数，则缓冲区中不会存储这些修改，git会直接丢弃这部分内容。可以使用 git push origin HEAD --force 强制将分区内容推送到远程服务器。 代码回退默认参数 -soft,所有commit的修改都会退回到git缓冲区参数--hard，所有commit的修改直接丢弃 $ git reset --hard HEAD^ 回退到上个版本 $ git reset --hard commit_id 退到/进到 指定commit_id 推送到远程 $ git push origin HEAD --force 可以吃的后悔药-&gt;版本穿梭当你回滚之后，又后悔了，想恢复到新的版本怎么办？ 用git reflog打印你记录你的每一次操作记录 $ git reflog 输出： c7edbfe HEAD@{0}: reset: moving to c7edbfefab1bdbef6cb60d2a7bb97aa80f022687 470e9c2 HEAD@{1}: reset: moving to 470e9c2 b45959e HEAD@{2}: revert: Revert &quot;add img&quot; 470e9c2 HEAD@{3}: reset: moving to 470e9c2 2c26183 HEAD@{4}: reset: moving to 2c26183 0f67bb7 HEAD@{5}: revert: Revert &quot;add img&quot; 找到你操作的id如：b45959e，就可以回退到这个版本 $ git reset --hard b45959e]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git指令整理]]></title>
    <url>%2F2017%2F02%2F15%2FGit%E6%8C%87%E4%BB%A4%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[随便整理的一些自用的Git指令 GitHub创建仓库提示代码echo &quot;# 项目名&quot; &gt;&gt; README.md git init git add README.md git commit -m &quot;first commit&quot; git remote add origin git@github.com:qiubaiying/项目名.git git push -u origin master 若仓库存在直接push git remote add origin git@github.com:qiubaiying/test.git git push -u origin master 常用操作创建仓库（初始化）在当前指定目录下创建 git init 新建一个仓库目录 git init [project-name] 克隆一个远程项目 git clone [url] 添加文件到缓存区添加所有变化的文件 git add . 添加名称指定文件 git add text.txt 配置设置提交代码时的用户信息 git config [--global] user.name &quot;[name]&quot; git config [--global] user.email &quot;[email address]&quot; 提交提交暂存区到仓库区 git commit -m &quot;msg&quot; # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何新变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化 $ git commit --amend [file1] [file2] ... 远程同步# 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all 分支# 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，但依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git checkout -b [branch] # 新建一个分支，指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并进当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] 标签Tags添加标签 在当前commit git tag -a v1.0 -m &apos;xxx&apos; 添加标签 在指定commit git tag v1.0 [commit] 查看 git tag 删除 git tag -d V1.0 删除远程tag git push origin :refs/tags/[tagName] 推送 git push origin --tags 拉取 git fetch origin tag V1.0 新建一个分支，指向某个tag git checkout -b [branch] [tag] 查看信息# 显示有变更的文件 $ git status # 显示当前分支的版本历史 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog 撤销# 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop 其他# 生成一个可供发布的压缩包 $ git archives]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>终端</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随便聊聊]]></title>
    <url>%2F2017%2F02%2F14%2F%E9%9A%8F%E4%BE%BF%E8%81%8A%E8%81%8A%2F</url>
    <content type="text"><![CDATA[随便谈谈今天是情人节，首先祝大家情人节快乐~ 在这特殊的节日里，我特意花了半天的时间，我将在简书中的文章都搬到 BY Blog 上，顺便又修改了下博客框架。 关于分享最近有很多人来请教我关于建站的问题，我都花时间为其解答一一解答。 感觉在解答别人的问题时，你自己也能学到很多新的知识，同时能沉浸其中。 我想这就是分享的魔力吧。 所以，把问题都砸过来吧~]]></content>
      <tags>
        <tag>生活</tag>
        <tag>博客</tag>
        <tag>漫谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速搭建个人博客]]></title>
    <url>%2F2017%2F02%2F06%2F%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[正所谓前人栽树，后人乘凉。 感谢Huxpro提供的博客模板 我的的博客 前言从 Jekyll 到 GitHub Pages 中间踩了许多坑，终于把我的个人博客BY Blog搭建出来了。。。 本教程针对的是不懂技术又想搭建个人博客的小白，操作简单暴力且快速。当然懂技术那就更好了。 看看看博客的主页样式： 在手机上的布局： 废话不多说了，开始进入正文。 快速开始从注册一个Github账号开始我采用的搭建博客的方式是使用 GitHub Pages + jekyll 的方式。 要使用 GitHub Pages，首先你要注册一个GitHub账号，GitHub 是全球最大的同性交友网站(吐槽下程序员~)，你值得拥有。 拉取我的博客模板注册完成后搜索 qiubaiying.github.io 进入我的仓库 点击右上角的 Fork 将我的仓库拉倒你的账号下 稍等一下，点击刷新，你会看到Fork了成功的页面 修改仓库名点击settings进入设置 修改仓库名为 你的Github账号名.github.io，然后 Rename 这时你在在浏览器中输入 你的Github账号名.github.io 例如:baiyingqiu.github.io 你将会看到如下界面 说明已经成功一半了😀。。。当然，还需要修改博客的配置才能变成你的博客。 若是出现 则需要 检查一下你的仓库名是否正确 整个网站结构修改Blog前我们来看看Jekyll 网站的基础结构，当然我们的网站比这个复杂。 123456789101112131415161718├── _config.yml├── _drafts| ├── begin-with-the-crazy-ideas.textile| └── on-simplicity-in-technology.markdown├── _includes| ├── footer.html| └── header.html├── _layouts| ├── default.html| └── post.html├── _posts| ├── 2007-10-29-why-every-programmer-should-play-nethack.textile| └── 2009-04-26-barcamp-boston-4-roundup.textile├── _data| └── members.yml├── _site├── img└── index.html 很复杂看不懂是不是，不要紧，你只要记住其中几个OK了 _config.yml 全局配置文件 _posts 放置博客文章的文件夹 img 存放图片的文件夹 其他的想继续深究可以看这里 修改博客配置来到你的仓库，找到_config.yml文件,这是网站的全局配置文件。 点击修改 然后编辑_config.yml的内容 接下来我们来详细说说以下配置文件的内容： 基础设置123456789# Site settingstitle: You Blog #你博客的标题SEOTitle: 你的博客 | You Blog #显示在浏览器上搜索的时候显示的标题header-img: img/post-bg-rwd.jpg #显示在首页的背景图片email: You@gmail.com description: &quot;You Blog&quot; #网站介绍keyword: &quot;BY, BY Blog, 柏荧的博客, qiubaiying, 邱柏荧, iOS, Apple, iPhone&quot; #关键词url: &quot;https://qiubaiying.github.io&quot; # 这个就是填写你的博客地址baseurl: &quot;&quot; # 这个我们不用填写 侧边栏1234# Sidebar settingssidebar: true # 是否开启侧边栏.sidebar-about-description: &quot;说点装逼的话。。。&quot;sidebar-avatar:/img/avatar-by.JPG # 你的个人头像 这里你可以改成我在img文件夹中的两张备用照片 img/avatar-m 或 avatar-g 社交账号展示你的其他社交平台 在下面你的社交账号的用户名就可以了，若没有可不用填 1234567# SNS settingsRSS: falseweibo_username: usernamezhihu_username: usernamegithub_username: usernamefacebook_username: usernamejianshu_username: jianshu_id 新加入了简书，jianshu_id 在你打开你的简书主页后的地址如：http://www.jianshu.com/u/e71990ada2fd中，后面这一串数字：e71990ada2fd 评论系统博客中使用的是 Disqus 评论系统，在 官网 注册帐号后，按下面的步骤简单的配置即可： 进入 设置页面 配置个人信息 找到 Username 这个 Username 就是我们 _config.yml 中 disqus_username 12# Disqus settings（https://disqus.com/）disqus_username: qiubaiying 很对人反映 Disqus 评论插件加载不出来，因为 Disqus 在国内加载缓慢，所以我新集成了 Gitalk 评论插件（感谢@FeDemo的推荐），喜欢折腾的朋友可以看这篇：《为博客添加 Gitalk 评论插件》。 我已经在_config.yml 配置就好了，只需要填写参数可以了。 网站统计集成了 Baidu Analytics 和 Google Analytics，到各个网站注册拿到track_id替换下面的就可以了 这是我的 Google Analytics 不要使用我的track_id😂。。。 若不想启用统计，直接删除或注释掉就可以了 1234567# Analytics settings# Baidu Analyticsba_track_id: 83e259f69b37d02a4633a2b7d960139c# Google Analyticsga_track_id: &apos;UA-90855596-1&apos; # Format: UA-xxxxxx-xxga_domain: auto 好友123456789101112friends: [ &#123; title: &quot;简书·BY&quot;, href: &quot;http://www.jianshu.com/u/e71990ada2fd&quot; &#125;,&#123; title: &quot;Apple&quot;, href: &quot;https://apple.com&quot; &#125;,&#123; title: &quot;Apple Developer&quot;, href: &quot;https://developer.apple.com/&quot; &#125;] 保存讲网页拉倒底部，点击 Commit changes 提交保存 再次进入你的主页， 恭喜你，你的个人博客搭建完成了😀。 写文章利用 Github网站 ，我们可以不用学习git，就可以轻松管理自己的博客 对于轻车熟路的程序猿来说，使用git管理会更加方便。。。 创建文章统一放在网站根目录下的 _posts 的文件夹中。 创建一个文件 在下面写文章，和标题，还能实时预览，最后提交保存就能看到自己的新文章了。 格式每一篇文章文件命名采用的是2017-02-04-Hello-2017.md时间+标题的形式，空格用-替换连接。 文件的格式是 .md 的 MarkDown 文件。 我们的博客文章格式采用是 MarkDown+ YAML 的方式。 YAML 就是我们配置 _config文件用的语言。 MarkDown 是一种轻量级的「标记语言」，很简单。花半个小时看一下就能熟练使用了 大概就是这么一个结构。 12345678910111213141516---layout: post # 使用的布局（不需要改）title: My First Post # 标题 subtitle: Hello World, Hello Blog #副标题date: 2017-02-06 # 时间author: BY # 作者header-img: img/post-bg-2015.jpg #这篇文章标题背景图片catalog: true # 是否归档tags: #标签 - 生活---## Hey&gt;这是我的第一篇博客。进入你的博客主页，新的文章将会出现在你的主页上. 按格式创建文章后，提交保存。进入你的博客主页，新的文章将会出现在你的主页上. 到这里，恭喜你！ 你已经成功搭建了自己的个人博客以及学会在博客上撰写文字的技能了（是不是有点小兴奋🙈）。 首页标签在首页可以看到这些特色标签，当你的文章出现相同标签（默认相同的标签数量大于1），才会自动生成。 所以当你只放一篇文章的时候是不会出现标签的。 建站的初期，博客比较少，若你想直接在首页生成比较多的标签。你可以在 _congfig.yml中找到这段： 123# Featured Tagsfeatured-tags: true # 是否使用首页标签featured-condition-size: 1 # 相同标签数量大于这个数，才会出现在首页 将其修改为featured-condition-size: 0, 这样只有一个标签时也会出现在首页了。 相反，当你博客比较多，标签也很多时，这时你就需要改回 1 甚至是 2 了。 自定义域名搭建好博客之后 你可能不想直接使用 baiyingqiu.github.io 这么长的博客域名吧, 想换成想 qiubaiying.top 这样简短的域名。那我们开始吧！ 购买域名首先，你必须购买一个自己的域名。 我是在阿里云购买的域名 用阿里云 app也可以注册域名，域名的价格根据后缀的不同和域名的长度而分，比如我这个 qiubaiying.top 的域名第一年才只要4元~ 域名尽量选择短一点比较好记住，注意，不能选择中文域名，比如 张三.top ,GitHub Pages 无法处理中文域名，会导致你的域名在你的主页上使用。 注册的步骤就不在介绍了 解析域名注册好域名后，需要将域名解析到你的博客上 管理控制台 → 域名与网站（万网） → 域名 选择你注册好的域名，点击解析 添加解析 分别添加两个A 记录类型, 一个主机记录为 www,代表可以解析 www.qiubaiying.top的域名 另一个为 @, 代表 qiubaiying.top 记录值就是我们博客的IP地址，是 GitHub Pagas 在美国的服务器的地址 151.101.100.133 可以通过 这个网站 或者直接在终端输入ping 你的地址，查看博客的IP ping qiubaiying.github.io 细心地你会发现所有人的博客都解析到 151.101.100.133 这个IP。 然后 GitHub Pages 再通过 CNAME记录 跳转到你的主页上。 修改CNAME最后一步，只需要修改 我们github仓库下的 CNAME 文件。 选择 CNAME 文件 使用的注册的域名进行替换,然后提交保存 这时，输入你自己的域名，就可以解析到你的主页了。 大功告成！ 进阶若你对博客模板进行修改，你就要看看 Jekyll 的开发文档,是中文文档哦，对英语一般的朋友简直是福利啊（比如说我😀）。 还要学习 Git 和 GitHub 的工作机制了及使用。 你可以先看看这个git教程，对git有个初步的了解后，那么相信你就能将自己图片传到GitHub仓库上，或者可以说掌握了 使用git管理自己的GitHub仓库 的技能呢。 对于轻车熟路的程序猿来说，这篇教程就算就结束了，因为下面的内容对于你们来说 so eazy~ 但相信很多小白都一脸懵逼，那我们继续👇。 利用GithHub Desktop管理GitHub仓库GithHub Desktop 是 GithHub 推出的一款管理GitHub仓库的桌面软件，换句话说就是将你在Github上的文件同步到本地电脑上，并将修改后的文件同步到Github远程仓库。 下载点击图片进入下载页面，选择对应的平台进行下载 下面以Mac平台为例： 安装将下载好的文件解压，将这只小猫拖到应用程序文件夹中 就可以在Launchpad找到这只小猫咪~ 登录点开应用,会弹出登录框， 输入你的GitHub账号和密码进行登录 登录后关闭窗口 然后返回引导窗，一直按 Continue 继续 Continue 还是Continue~ 进入主界面，先 右键Remve 删除这个用户指导，贼烦~ 克隆仓库选择你的仓库克隆到本地 管理仓库现在文件夹中打开 打开后你会的发现文件结构和你在Github上的一模一样~ 你最先关心的可能是你的头像~在img文件夹中把替换我的头像就好了。 不仅是图片，所有在Github上的的操作都可以进行。 保存修改当你对仓库文件夹的文件下进行修改、添加或删除时，都可以在 GitHub Desktop 中看到 例如我在 img 中添加了一张图片 avatar-demo.png 添加了一张图片 就可以在看到GitHub Desktop显示了我的修改 保存修改只要按 Commit to master，然后可以写上你的修改说明 同步将修改同步到 GitHub 远程仓库上只需要一步：点击右上角的同步按钮 完成打开你的GitHub上的仓库，你就可以看到已经和本地同步了 可以看到你提交的详情： add img 这样，你已经能轻松管理自己的博客了。 想上传头像，背景，或者是删掉你不要的图片（我的头像😏）已经是 so eazy了吧~ 注意你在 GitHub 网站上进行 Commit 操作后，需要在GitHub Desktop上按一下 同步按键 才能同步网站上的修改到你的本地。 修改个人介绍 修改个人介绍需要修改根目录下的 about.html 文件 看不懂 HTML 标签？没关系，对照着修改就好了~ 还有注意这个有中英介绍 常见问题最近有很多人给我提问题，我这边总结一下 配置文件修改后没有效果刷新几遍浏览器就好了~ 不行的话，先清除浏览器缓存再试试。 404错误 检查你的仓库名是否有按照要求填写 确定 Fork 的是不是我的仓库~ 修改CNAME文件，域名还是不变清除浏览器缓存就OK~ 其他问题直接在评论中提出来或私信我，我会一一替大家解决的😀 其他最近有人往我的远程仓库不停的 push，一天连收几十封邮件！例如像这样的 原因大多是直接Clone了我的仓库到本地，没有删除我的远程仓库地址，添加完自己的仓库地址后，一口气推送到所有远程仓库（包括我的😂）~ 打扰了我的工作和生活~ 所以，请不要往我的仓库上推送分支！ 我发现一个问题是，很多人每次修改博客的内容都commit一次到远程仓库，然后再查看修改结果，这样效率非常低！ 来，上车！在本地调试博客 注：下面的操作是在 Mac 终端进行的。Windows 环境下的配置请参考 @梦幻之云 提供的 这篇文章。 有心的同学在 jekyll官网 就会发现 jekyll 的 提供的实例代码。 123456~ $ gem install jekyll bundler~ $ jekyll new my-awesome-site~ $ cd my-awesome-site~/my-awesome-site $ bundle install~/my-awesome-site $ bundle exec jekyll serve# =&gt; 打开浏览器 http://localhost:4000 这段命令创建了一个默认的 jekll 网站，然后在本机的 4000 窗口展示。聪明的你应该发现怎么做了吧~ 安装 jekyll和 jekyll bundler 12$ gem install jekyll$ gem install jekyll bundler 进入你的 Blog 所在目录，然后创建本地服务器 1$ jekyll s 然后会显示 1234 Auto-regeneration: enabled for &apos;/Users/baiying/Blog&apos;Configuration file: /Users/baiying/Blog/_config.yml Server address: http://127.0.0.1:4000/ Server running... press ctrl-c to stop. 你就可以在 http://127.0.0.1:4000/ 看到你的博客，你对本地博客的修改都会在这个地址进行显示，这大大提高了对博客的配置效率。 使用ctrl+c就可以停止 serve Star若本教程顺利帮你搭建了自己的个人博客，请不要 害羞，给我的 github仓库 点个 star 吧！ 因为最近发现 Fork 将近破百，加上直接 Clone 仓库的，保守估计已经帮助上百人成功的搭建了自己的博客，可是 Star 却仅仅只有 12！可能还是做的不够好吧！现在已经破百了，感谢大家的Star！ 别无他求，点个 Star 吧！ 心满意足！ 补充修改网站的 icon 要修改如图所示的网站 icon： 在博客 img 目录下找到并替换 favicon.ico 这个图标即可，图标尺寸为32x32。 修改主页的座右铭最近有不少小伙伴私信我：如何修改主页的座右铭？ 就是这个： 很简单，找到博客目录下的 index.html 文件，修改这句话就可以了。 如何在博客文章中上插入图片博客的文章用的是 MarkDown 格式，如果没用过 MarkDown 真的 强烈推荐 花半个小时学习一下。 MarkDown 中添加图片的形式是 :![](图片的URL) 例如： ![MarkDown示例图片](http://upload-images.jianshu.io/upload_images/2178672-eb2effd6b942a500.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)就会显示下面这张图片 https://ws3.sinaimg.cn/large/006tNc79gy1fj9xhjzobbj30yg0my75z.jpg就是这张图片的URL，我们可以在浏览器输入这个URL找到或下载这张图片。 所以，要在 MacDown 中插入图片，这张图片就需要上传到图床（网上），然后在引用这张图片的URL。 将图片上传到图床Mac 上的图床神器：iPic 直接在App Store上下载，谁用谁知道！ 使用方法很简单，直接拖动图片到 P 图标上，或者选中图片按快捷键 ⌘+U，就能请示上传。 上传成功就能直接粘贴图片的URL。 用 iPic 上传图片后，获取URL插入文章中就可以了。 推荐几个好用软件MarkDown编辑器MacDown：可能是Mac上最好的MacDown编辑器了 图片压缩工具ImageOptim 对于我们的博客来说，图片越大，加载速度越慢。 不信你用手机打开你的博客试试~ 所以有必要对我们上传到博客网站中的图片：指的是你的头像，首页背景图片，文章背景图片等。对于博客文章中插入的图片，其实也可以压缩了再上传。 对博客中的所有图片进行压缩： 看看压缩结果，最高的一张压缩了78.7%，这简直是太可怕了！ 好了，现在个人博客的加载速度估计要起飞了~ 最后要说个事情我在博客中的文章，你们可以保留，让更多需要帮助人的看到，当然也可以删除。 但是，我发现居然有人把文章的作者改成了自己，然后当成自己的文章放在自己的博客上，这就令人感到气愤了。 比如说向我请教问题的这位： 我在博客中的每篇文章都是我一字一句敲出来的，转载的文章我也注明了出处，表示对原作者的尊重。同时也希望大家都能尊重我的付出。 谢谢~]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveCocoa 基础]]></title>
    <url>%2F2016%2F12%2F26%2FReactiveCocoa-%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[ReactiveCocoa基础 本文修改自最快让你上手ReactiveCocoa之基础篇 有关对 ReactiveCocoa 的看法可以看一下唐巧的这篇ReactiveCocoa 讨论会 ReactiveCocoa简介 ReactiveCocoa（简称为RAC）,是由Github开源的一个应用于iOS和OS开发的新框架,Cocoa是苹果整套框架的简称，因此很多苹果框架喜欢以Cocoa结尾。 在我们iOS开发过程中，当某些事件响应的时候，需要处理某些业务逻辑,这些事件都用不同的方式来处理。 比如按钮的点击使用action，ScrollView滚动使用delegate，属性值改变使用KVO等系统提供的方式。其实这些事件，都可以通过RAC处理 ReactiveCocoa为事件提供了很多处理方法，而且利用RAC处理事件很方便，可以把要处理的事情，和监听的事情的代码放在一起，这样非常方便我们管理，就不需要跳到对应的方法里。 非常符合我们开发中高聚合，低耦合的思想。 ReactiveCocoa编程思想在开发中我们也不能太依赖于某个框架，否则这个框架不更新了，导致项目后期没办法维护，比如之前Facebook提供的 Three20 框架，在当时也是神器，但是后来不更新了，也就没什么人用了。因此我感觉学习一个框架，还是有必要了解它的编程思想。 先简单介绍下目前咱们已知的编程思想: 响应式编程思想响应式编程思想：不需要考虑调用顺序，只需要知道考虑结果，类似于蝴蝶效应，产生一个事件，会影响很多东西，这些事件像流一样的传播出去，然后影响结果，借用面向对象的一句话，万物皆是流。 代表：KVO 链式编程思想链式编程 是将多个操作（多行代码）通过点号(.)链接在一起成为一句代码,使代码可读性好。如: 1make.add(1).add(2).sub(5).muilt(-4).divide(4); 特点：方法的返回值是block,block必须有返回值（本身对象），block参数（需要操作的值） 代表：masonry框架。 实现：模仿masonry，写一个加法计算器，练习链式编程思想。 NSObject+Caculator.h 12345678910# import &lt;Foundation/Foundation.h&gt;@class CaculatorMaker;@interface NSObject (Caculator)// 计算+ (int)makeCaculators:(void (^)(CaculatorMaker *))block; @end NSObject+Caculator.m 123456789101112@implementation NSObject (Caculator)+ (int)makeCaculators:(void (^)(CaculatorMaker *))block &#123; CaculatorMaker *mgr = [[CaculatorMaker alloc] init]; block(mgr); return (mgr.result);&#125;@end CaculatorMaker.h 123456789101112131415161718# import &lt;Foundation/Foundation.h&gt;@class CaculatorMaker;typedef CaculatorMaker *(^CasulatorBlock)(int);@interface CaculatorMaker : NSObject@property (nonatomic, assign) int result;// 算数方法- (CaculatorMaker *(^)(int))add;- (CasulatorBlock)sub;- (CasulatorBlock)muilt;- (CasulatorBlock)divide;@end CaculatorMaker.m 123456789101112131415161718192021222324252627282930313233343536373839404142434445# import &quot;CaculatorMaker.h&quot;@implementation CaculatorMaker- (CaculatorMaker *(^)(int))add &#123; return ^CaculatorMaker *(int value) &#123; _result += value; return self; &#125;;&#125;- (CasulatorBlock)sub &#123; return ^CaculatorMaker *(int value) &#123; _result -= value; return self; &#125;;&#125;- (CasulatorBlock)muilt &#123; return ^CaculatorMaker *(int value) &#123; _result *= value; return self; &#125;;&#125;- (CasulatorBlock)divide &#123; return ^CaculatorMaker *(int value) &#123; _result /= value; return self; &#125;;&#125;@end 使用： 12345678int result = [NSObject makeCaculators:^(CaculatorMaker *make) &#123; // ( 1 + 2 - 5 ) * (-4) / 4 make.add(1).add(2).sub(5).muilt(-4).divide(4); &#125;]; NSLog(@&quot;%d&quot;, result); 函数式编程思想函数式编程思想：是把操作尽量写成一系列嵌套的函数或者方法调用。 特点：每个方法必须有返回值（本身对象）,把函数或者Block当做参数,block参数（需要操作的值）block返回值（操作结果） 代表：ReactiveCocoa 实现：用函数式编程实现，写一个加法计算器,并且加法计算器自带判断是否等于某个值. 123456789101112131415Calculator *caculator = [[Calculator alloc] init];BOOL isqule = [[[caculator caculator:^int(int result) &#123; result += 2; result *= 5; return result; &#125;] equle:^BOOL(int result) &#123; return result == 10; &#125;] isEqule];NSLog(@&quot;%d&quot;, isqule); Calculator.h 12345678910111213#import &lt;Foundation/Foundation.h&gt;@interface Calculator : NSObject@property (nonatomic, assign) BOOL isEqule;@property (nonatomic, assign) int result;- (Calculator *)caculator:(int (^)(int result))caculator;- (Calculator *)equle:(BOOL (^)(int result))operation;@end Calculator.m 123456789101112131415161718192021#import &quot;Calculator.h&quot;@implementation Calculator- (Calculator *)caculator:(int (^)(int))caculator &#123; _result = caculator(_result); return self; &#125;- (Calculator *)equle:(BOOL (^)(int))operation &#123; _isEqule = operation(_result); return self;&#125;@end ReactiveCocoa 结合了这两种种编程风格： 函数式编程（Functional Programming） 响应式编程（Reactive Programming） 所以，你可能听说过 ReactiveCocoa 被描述为函数响应式编程（FRP）框架。 以后使用RAC解决问题，就不需要考虑调用顺序，直接考虑结果，把每一次操作都写成一系列嵌套的方法中，使代码高聚合，方便管理。 导入ReactiveCocoa ReactiveCocoa的GitHub地址 Objective-CReactiveCocoa 2.5版本以后改用了Swift，所以Objective-C项目需要导入2.5版本 CocoaPods集成： 12345678platform :ios, &apos;8.0&apos;target &apos;YouProjectName&apos; douse_frameworks!pod &apos;ReactiveCocoa&apos;, &apos;~&gt; 2.5&apos;end PS:新版本的CocoaPods需要加入 123target &apos;YouProjectName&apos; do ... end 这句话来限定项目，否则导入失败。 SwiftSwift项目导入2.5后的版本 12345678platform :ios, &apos;8.0&apos;target &apos;YouProjectName&apos; douse_frameworks!pod &apos;ReactiveCocoa&apos;end 使用时在全局头文件导入头文件即可 PrefixHeader.pch 123456#ifndef PrefixHeader_pch#define PrefixHeader_pch#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;#endif ReactiveCocoa常见类RACSiganl 信号类 信号类,一般表示将来有数据传递，只要有数据改变，信号内部接收到数据，就会马上发出数据。 注意： 信号类(RACSiganl)，只是表示当数据改变时，信号内部会发出数据，它本身不具备发送信号的能力，而是交给内部一个订阅者去发出。 默认一个信号都是冷信号，也就是值改变了，也不会触发，只有订阅了这个信号，这个信号才会变为热信号，值改变了才会触发。 如何订阅信号：调用信号RACSignal的subscribeNext就能订阅 使用： 1234567891011121314151617181920212223242526272829303132333435363738394041// RACSignal使用步骤： // 1.创建信号 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe // 2.订阅信号,才会激活信号. - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock // 3.发送信号 - (void)sendNext:(id)value // RACSignal底层实现： // 1.创建信号，首先把didSubscribe保存到信号中，还不会触发。 // 2.当信号被订阅，也就是调用signal的subscribeNext:nextBlock // 2.2 subscribeNext内部会创建订阅者subscriber，并且把nextBlock保存到subscriber中。 // 2.1 subscribeNext内部会调用siganl的didSubscribe // 3.siganl的didSubscribe中调用[subscriber sendNext:@1]; // 3.1 sendNext底层其实就是执行subscriber的nextBlock // 1.创建信号 RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // block调用时刻：每当有订阅者订阅信号，就会调用block。 // 2.发送信号 [subscriber sendNext:@1]; // 如果不在发送数据，最好发送信号完成，内部会自动调用[RACDisposable disposable]取消订阅信号。 [subscriber sendCompleted]; return [RACDisposable disposableWithBlock:^&#123; // block调用时刻：当信号发送完成或者发送错误，就会自动执行这个block,取消订阅信号。 // 执行完Block后，当前信号就不在被订阅了。 NSLog(@&quot;信号被销毁&quot;); &#125;]; &#125;]; // 3.订阅信号,才会激活信号. [siganl subscribeNext:^(id x) &#123; // block调用时刻：每当有信号发出数据，就会调用block. NSLog(@&quot;接收到数据:%@&quot;,x); &#125;]; RACSubscriber 表示订阅者的意思，用于发送信号，这是一个协议，不是一个类，只要遵守这个协议，并且实现方法才能成为订阅者。通过create创建的信号，都有一个订阅者，帮助他发送数据。 RACDisposable 用于取消订阅或者清理资源，当信号发送完成或者发送错误的时候，就会自动触发它。 使用场景：不想监听某个信号时，可以通过它主动取消订阅信号。 RACSubject RACSubject:信号提供者，自己可以充当信号，又能发送信号。 使用场景:通常用来代替代理，有了它，就不必要定义代理了。 RACReplaySubject 重复提供信号类，RACSubject的子类。 RACReplaySubject与RACSubject区别: RACReplaySubject可以先发送信号，在订阅信号，RACSubject就不可以。 使用场景一:如果一个信号每被订阅一次，就需要把之前的值重复发送一遍，使用重复提供信号类。 使用场景二:可以设置capacity数量来限制缓存的value的数量,即只缓充最新的几个值。 ACSubject 和 RACReplaySubject 简单使用： ACSubject 123456789101112131415161718192021222324 // RACSubject使用步骤// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。// 2.订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock// 3.发送信号 sendNext:(id)value// RACSubject:底层实现和RACSignal不一样。// 1.调用subscribeNext订阅信号，只是把订阅者保存起来，并且订阅者的nextBlock已经赋值了。// 2.调用sendNext发送信号，遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。// 1. 创建信号RACSubject *subject = [RACSubject subject];// 2.订阅信号[subject subscribeNext:^(id x) &#123; // block调用时机：当信号发出新值，就会调用 NSLog(@&quot;收到信号&quot;); &#125;];// 3.发送信号NSLog(@&quot;发送信号&quot;);[subject sendNext:@&quot;1&quot;]; 12345678910111213141516171819202122232425262728293031323334 // RACReplaySubject使用步骤:// 1.创建信号 [RACSubject subject]，跟RACSiganl不一样，创建信号时没有block。// 2.可以先订阅信号，也可以先发送信号。// 2.1 订阅信号 - (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock// 2.2 发送信号 sendNext:(id)value// RACReplaySubject:底层实现和RACSubject不一样。// 1.调用sendNext发送信号，把值保存起来，然后遍历刚刚保存的所有订阅者，一个一个调用订阅者的nextBlock。// 2.调用subscribeNext订阅信号，遍历保存的所有值，一个一个调用订阅者的nextBlock// 如果想当一个信号被订阅，就重复播放之前所有值，需要先发送信号，在订阅信号。// 也就是先保存值，在订阅值。// 1.创建信号RACReplaySubject *replaySubject = [RACReplaySubject subject];// 3.先订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;第一个订阅者接受到的数据%@&quot;, x);&#125;];// 2.发送信号[replaySubject sendNext:@1];[replaySubject sendNext:@2];// 后订阅信号[replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;第二个订阅者接收到的数据%@&quot;,x);&#125;]; RACSubject替换代理（与block类似） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 需求: // 1.给当前控制器添加一个按钮，modal到另一个控制器界面 // 2.另一个控制器view中有个按钮，点击按钮，通知当前控制器步骤一：在第二个控制器.h，添加一个RACSubject代替代理。@interface TwoViewController : UIViewController@property (nonatomic, strong) RACSubject *delegateSignal;@end步骤二：监听第二个控制器按钮点击@implementation TwoViewController- (IBAction)notice:(id)sender &#123; // 通知第一个控制器，告诉它，按钮被点了 // 通知代理 // 判断代理信号是否有值 if (self.delegateSignal) &#123; // 有值，才需要通知 [self.delegateSignal sendNext:nil]; &#125;&#125;@end步骤三：在第一个控制器中，监听跳转按钮，给第二个控制器的代理信号赋值，并且监听.@implementation OneViewController - (IBAction)btnClick:(id)sender &#123; // 创建第二个控制器 TwoViewController *twoVc = [[TwoViewController alloc] init]; // 设置代理信号 twoVc.delegateSignal = [RACSubject subject]; // 订阅代理信号 [twoVc.delegateSignal subscribeNext:^(id x) &#123; NSLog(@&quot;点击了通知按钮 %@&quot;, x); &#125;]; // 跳转到第二个控制器 [self presentViewController:twoVc animated:YES completion:@&quot;hi&quot;];&#125;@end RACTuple 元组类,类似NSArray,用来包装值.(@[key, value]) RACSequence RAC中的集合类，用于代替NSArray,NSDictionary,可以使用它来快速遍历数组和字典。 使用场景：字典转模型 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 1.遍历数组NSArray *numbers = @[@1,@2,@3,@4];// 这里其实是三步// 第一步: 把数组转换成集合RACSequence numbers.rac_sequence// 第二步: 把集合RACSequence转换RACSignal信号类,numbers.rac_sequence.signal// 第三步: 订阅信号，激活信号，会自动把集合中的所有值，遍历出来。[numbers.rac_sequence.signal subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;, x);&#125;];// 2.遍历字典,遍历出来的键值对 都会包装成 RACTuple(元组对象) @[key, value]NSDictionary *dic = @&#123;@&quot;name&quot;: @&quot;BYqiu&quot;, @&quot;age&quot;: @18&#125;;[dic.rac_sequence.signal subscribeNext:^(RACTuple *x) &#123; // 解元组包，会把元组的值，按顺序给参数里的变量赋值 // 写法相当与 // NSString *key = x[0]; // NSString *value = x[1]; RACTupleUnpack(NSString *key, NSString *value) = x; NSLog(@&quot;key:%@, value:%@&quot;, key, value); &#125;];// 3.字典转模型NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;flags.plist&quot; ofType:nil];NSArray *dicArray = [NSArray arrayWithContentsOfFile:filePath];NSMutableArray *items = [NSMutableArray array];// OC写法for (NSDictionary *dic in dicArray) &#123; //FlagItem *item = [FlagItem flagWithDict:dict]; //[items addObject:item];&#125;// RAC写法[dicArray.rac_sequence.signal subscribeNext:^(id x) &#123; // 利用RAC遍历， x：字典 //FlagItem *item = [FlagItem flagWithDict:x]; //[items addObject:item];&#125;];// RAC高级用法（函数式编程）NSArray *flags = [[dicArray.rac_sequence map:^id(id value) &#123; return [FlagItem flagWithDict:value]; &#125;] array]; RACCommand RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。 一、RACCommand使用步骤: 创建命令 initWithSignalBlock:(RACSignal * (^)(id input))signalBlock 在signalBlock中，创建RACSignal，并且作为signalBlock的返回值 执行命令 - (RACSignal *)execute:(id)input 二、RACCommand使用注意: signalBlock必须要返回一个信号，不能传nil. 如果不想要传递信号，直接创建空的信号[RACSignal empty]; RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。 三、RACCommand设计思想： 内部signalBlock为什么要返回一个信号，这个信号有什么用。 在RAC开发中，通常会把网络请求封装到RACCommand，直接执行某个RACCommand就能发送请求。 当RACCommand内部请求到数据的时候，需要把请求的数据传递给外界，这时候就需要通过signalBlock返回的信号传递了。 四、如何拿到RACCommand中返回信号发出的数据。 RACCommand有个执行信号源executionSignals，这个是signal of signals(信号的信号),意思是信号发出的数据是信号，不是普通的类型。 订阅executionSignals就能拿到RACCommand中返回的信号，然后订阅signalBlock返回的信号，就能获取发出的值。 五、监听当前命令是否正在执行executing 六、使用场景,监听按钮点击，网络请求 使用: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354// 1.创建命令 RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; NSLog(@&quot;执行命令&quot;); // 返回空信号 //return [RACSignal empty]; // 2.创建信号 传递数据 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;请求数据&quot;]; // 注意：数据传递完，最好调用sendCompleted,这时命令才执行完毕 [subscriber sendCompleted]; return nil; &#125;]; &#125;]; // 强引用命令，不要被销毁，否则接收不到数据 _command = command; // 3.订阅RACCommand的信号 [command.executionSignals subscribeNext:^(id x) &#123; [x subscribeNext:^(id x) &#123; NSLog(@&quot;订阅RACCommand的信号: %@&quot;, x); &#125;]; &#125;]; // RAC高级用法 // switchToLatest:用于signal of signals，获取signal of signals发出的最新信号,也就是可以直接拿到RACCommand中的信号 [command.executionSignals.switchToLatest subscribeNext:^(id x) &#123; NSLog(@&quot;RAC高级用法: %@&quot;, x); &#125;]; // 4.监听命令是否执行完毕,默认会来一次，可以直接跳过，skip表示跳过第一次信号。 [[command.executing skip:1] subscribeNext:^(id x) &#123; if ([x boolValue] == YES) &#123; // 正在执行 NSLog(@&quot;正在执行&quot;); &#125; else &#123; // 执行完毕 NSLog(@&quot;执行完成&quot;); &#125; &#125;]; // 5.执行命名 [self.command execute:@1]; RACMulticastConnection 用于当一个信号，被多次订阅时，为了保证创建信号时，避免多次调用创建信号中的block，造成副作用，可以使用这个类处理。 注意：RACMulticastConnection通过RACSignal的-publish或者-muticast:方法创建. RACMulticastConnection使用步骤: 创建信号 + (RACSignal )createSignal:(RACDisposable (^)(id subscriber))didSubscribe 创建连接 RACMulticastConnection *connect = [signal publish]; 订阅信号,注意：订阅的不在是之前的信号，而是连接的信号。 [connect.signal subscribeNext:nextBlock] 连接 [connect connect] RACMulticastConnection底层原理: 创建connect，connect.sourceSignal -&gt; RACSignal(原始信号) connect.signal -&gt; RACSubject 订阅connect.signal，会调用RACSubject的subscribeNext，创建订阅者，而且把订阅者保存起来，不会执行block。 [connect connect]内部会订阅RACSignal(原始信号)，并且订阅者是RACSubject 订阅原始信号，就会调用原始信号中的didSubscribe didSubscribe，拿到订阅者调用sendNext，其实是调用RACSubject的sendNext RACSubject的sendNext,会遍历RACSubject所有订阅者发送信号。 因为刚刚第二步，都是在订阅RACSubject，因此会拿到第二步所有的订阅者，调用他们的nextBlock 需求：假设在一个信号中发送请求，每次订阅一次都会发送请求，这样就会导致多次请求。 解决：使用RACMulticastConnection就能解决. 问题：每次订阅一次都会发送请求 1234567891011121314151617181920// 创建请求信号RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;发送请求&quot;); [subscriber sendNext:@1]; return nil;&#125;];// 订阅信号[signal subscribeNext:^(id x) &#123; NSLog(@&quot;接受数据: %@&quot;, x);&#125;];// 再次订阅信号，会再次执行发送请求，也就是每次订阅都会发送一次请求[signal subscribeNext:^(id x) &#123; NSLog(@&quot;接受数据: %@&quot;, x);&#125;]; 输出： 12342016-12-28 11:37:04.397 ReactiveCacoa[1505:340573] 发送请求2016-12-28 11:37:04.398 ReactiveCacoa[1505:340573] 接受数据: 12016-12-28 11:37:04.398 ReactiveCacoa[1505:340573] 发送请求2016-12-28 11:37:04.398 ReactiveCacoa[1505:340573] 接受数据: 1 可以发现每次订阅都会重新发送请求. 下面我们使用RACMulticastConnection： 12345678910111213141516171819202122232425RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;发送请求&quot;); [subscriber sendNext:@1]; return nil;&#125;];// 创建连接RACMulticastConnection *connect = [signal publish];// 订阅信号// 注意：订阅信号，也不能激活信号，只是保存订阅者到数组，必须通过连接，当调用连接，就会一次性调用所有订阅者的SendNext[connect.signal subscribeNext:^(id x) &#123; NSLog(@&quot;订阅者1信号: %@&quot;, x);&#125;];[connect.signal subscribeNext:^(id x) &#123; NSLog(@&quot;订阅者2信号: %@&quot;, x);&#125;];// 连接、激活信号[connect connect]; 输出： 1232016-12-28 11:37:04.399 ReactiveCacoa[1505:340573] 发送请求2016-12-28 11:37:04.399 ReactiveCacoa[1505:340573] 订阅者1信号: 12016-12-28 11:37:04.399 ReactiveCacoa[1505:340573] 订阅者2信号: 1 RACScheduler RAC中的队列，用GCD封装的。 RACUnit 表⽰stream不包含有意义的值,也就是看到这个，可以直接理解为nil. RACEven 把数据包装成信号事件(signal event)。它主要通过RACSignal的-materialize来使用，然并卵。 ReactiveCocoa开发中常见用法 替换代理 替换KVO 监听事件 替换通知 监听文本框文字改变 统一处理多个网络请求 替换代理：rac_signalForSelector: rac_signalForSelector: 直接监听 Selector 事件的调用 应用场景：监听 RedViewController 中按钮的点击事件 btnTap: 跳转到RedViewController前，先使用rac_signalForSelector订阅rvc中的 btnTap: 点击事件 1234567891011121314// 使用segue跳转- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender &#123;- if ([segue.identifier isEqualToString:@&quot;goRedVC&quot;]) &#123; RedViewController *rvc = segue.destinationViewController; // 订阅rvc中的 btnTap: 点击事件 [[rvc rac_signalForSelector:@selector(btnTap:)] subscribeNext:^(id x) &#123; NSLog(@&quot;RedVC btnTap！&quot;); &#125;]; &#125;&#125; RedViewController.m 中的按钮事件 1234- (IBAction)btnTap:(id)sender &#123; NSLog(@&quot;!&quot;);&#125; 替换KVOrac_valuesForKeyPath: 123456// KVO// 监听 slider 的 value 变化[[self.slider rac_valuesForKeyPath:@&quot;value&quot; observer:nil] subscribeNext:^(id x) &#123; NSLog(@&quot;slider value Change：%@&quot;, x);&#125;]; 替换通知rac_addObserverForName 123456789101112// 原生的订阅通知[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(userDidChange:) name:kTTCurrentUserLoggedOffNotification object:nil]; // 使用RAC订阅通知 ，takeUntil限定信号的声明周期 [[[[NSNotificationCenter defaultCenter] rac_addObserverForName:UIApplicationDidEnterBackgroundNotification object:nil] takeUntil:[self rac_willDeallocSignal]] subscribeNext:^(id x) &#123; NSLog(@&quot;Notification received&quot;);&#125;]; 监听事件rac_signalForControlEvents: 12345// 监听 btn 的 UIControlEventTouchUpInside 点击事件[[self.btn rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(id x) &#123; NSLog(@&quot;btnTap&quot;);&#125;]; 监听 textField 文字变化rac_textSignal 1234[[self.textField rac_textSignal] subscribeNext:^(id x) &#123; NSLog(@&quot;textField change: %@&quot;, x);&#125;]; 统一处理多个网络请求rac_liftSelector: 1234567891011121314151617181920212223242526272829303132333435363738- (void)viewDidLoad &#123; [super viewDidLoad]; // 处理多个请求都返回结果的时候，统一处理 // 如同时进行多个网络请求，每个请求都正确返回时，再去刷新页面 RACSignal *signalOne = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 网络请求1 // ... // 返回成功 [subscriber sendNext:@&quot;网络请求1 data&quot;]; return nil; &#125;]; RACSignal *signalTwo = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; // 网络请求2 // ... // 返回成功 [subscriber sendNext:@&quot;网络请求2 data&quot;]; return nil; &#125;]; [self rac_liftSelector:@selector(updateWithR1:R2:) withSignalsFromArray:@[signalOne, signalTwo]]; &#125;// 更新界面- (void)updateWithR1:(id)r1 R2:(id)r2 &#123; NSLog(@&quot;R1:%@, R2：%@ 完成！&quot;, r1, r2); &#125; 注意： 替换KVO和 监听文本框文字改变 方法在创建监听方法时就会执行一次。 122016-12-28 16:53:50.746 ReactiveCacoa[4956:1246592] slider value Change：0.52016-12-28 16:53:50.748 ReactiveCacoa[4956:1246592] textField change: 使用rac_liftSelector时 @selector(updateWithR1:R2:)中的方 参数个数 要与 signal个数 相同，否则会被断言Crash！]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>ReactiveCocoa</tag>
        <tag>函数式编程</tag>
        <tag>开源框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时器 你真的会使用吗？]]></title>
    <url>%2F2016%2F12%2F13%2F%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言定时器的使用是软件开发基础技能，用于延时执行或重复执行某些方法。 我相信大部分人接触iOS的定时器都是从这段代码开始的: 1[NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(action:) userInfo:nil repeats:YES] 但是你真的会用吗？ 正文iOS定时器首先来介绍iOS中的定时器 iOS中的定时器大致分为这几类： NSTimer CADisplayLink GCD定时器 NSTimer使用方法NSTime定时器是我们比较常使用的定时器，比较常使用的方法有两种： 123+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(nullable id)userInfo repeats:(BOOL)yesOrNo; 这两种方法都是创建一个定时器，区别是用timerWithTimeInterval:方法创建的定时器需要手动加入RunLoop中。 1234// 创建NSTimer对象NSTimer *timer = [NSTimer timerWithTimeInterval:3 target:self selector:@selector(timerAction) userInfo:nil repeats:YES];// 加入RunLoop中[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; 需要注意的是： UIScrollView 滑动时执行的是 UITrackingRunLoopMode，NSDefaultRunLoopMode被挂起，会导致定时器失效，等恢复为滑动结束时才恢复定时器。其原因可以查看我这篇《Objective-C RunLoop 详解》中的 “RunLoop 的 Mode“章节，有详细的介绍。 举个例子： 12345678910- (void)startTimer&#123; NSTimer *UIScrollView = [NSTimer timerWithTimeInterval:0.5 target:self selector:@selector(action:) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];&#125;- (void)action:(NSTimer *)sender &#123; static int i = 0; NSLog(@&quot;NSTimer: %d&quot;,i); i++;&#125; 将timer添加到NSDefaultRunLoopMode中，没0.5秒打印一次，然后滑动UIScrollView. 打印台输出： 可以看出在滑动UIScrollView时，定时器被暂停了。 所以如果需要定时器在 UIScrollView 拖动时也不影响的话，有两种解决方法 timer分别添加到 UITrackingRunLoopMode 和 NSDefaultRunLoopMode中 12[[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode];[[NSRunLoop mainRunLoop] addTimer:timer forMode: UITrackingRunLoopMode]; 直接将timer添加到NSRunLoopCommonModes 中： 1[[NSRunLoop mainRunLoop] addTimer:timer forMode: NSRunLoopCommonModes]; 但并不是都timer所有的需要在滑动UIScrollView时继续执行，比如使用NSTimer完成的帧动画，滑动UIScrollView时就可以停止帧动画，保证滑动的流程性。 若没有特殊要求的话，一般使用第二种方法创建完timer，会自动添加到NSDefaultRunLoopMode中去执行，也是平时最常用的方法。 1NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(action:) userInfo:nil repeats:YES]; 参数： TimeInterval：延时时间 target:目标对象，一般就是self本身 selector:执行方法 userInfo:传入信息 repeats:是否重复执行 以上创建的定时器，若repeats参数设为NO，执行一次后就会被释放掉; 若repeats参数设为YES重复执行时，必须手动关闭，否则定时器不会释放(停止）。 释放方法： 12// 停止定时器[timer invalidate]; 实际开发中，我们会将NSTimer对象设置为属性，这样方便释放。 iOS10.0 推出了两个新的API，与上面的方法相比，selector换成Block回调以、减少传入的参数(那几个参数真是鸡肋)。不过开发中一般需要适配低版本，还是尽量使用上面的方法吧。 123+ (NSTimer *)timerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)interval repeats:(BOOL)repeats block:(void (^)(NSTimer *timer))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0)); ###特点 必须加入Runloop 上面不管使用哪种方法，实际最后都会加入RunLoop中执行，区别就在于是否手动加入而已。 存在延迟 不管是一次性的还是周期性的timer的实际触发事件的时间，都会与所加入的RunLoop和RunLoop Mode有关，如果此RunLoop正在执行一个连续性的运算，timer就会被延时出发。重复性的timer遇到这种情况，如果延迟超过了一个周期，则会在延时结束后立刻执行，并按照之前指定的周期继续执行，这个延迟时间大概为50-100毫秒. 所以NSTimer不是绝对准确的,而且中间耗时或阻塞错过下一个点,那么下一个点就pass过去了. UIScrollView滑动会暂停计时 添加到NSDefaultRunLoopMode的 timer 在 UIScrollView滑动时会暂停，若不想被UIScrollView滑动影响，需要将 timer 添加再到 UITrackingRunLoopMode 或 直接添加到NSRunLoopCommonModes 中 ##CADisplayLink CADisplayLink官方介绍： A CADisplayLink object is a timer object that allows your application to synchronize its drawing to the refresh rate of the display CADisplayLink对象是一个和屏幕刷新率同步的定时器对象。每当屏幕显示内容刷新结束的时候，runloop就会向CADisplayLink指定的target发送一次指定的selector消息， CADisplayLink类对应的 selector 就会被调用一次。 从原理上可以看出，CADisplayLink适合做界面的不停重绘，比如视频播放的时候需要不停地获取下一帧用于界面渲染，或者做动画。 ###使用方法 创建： 12345678@property (nonatomic, strong) CADisplayLink *displayLink;self.displayLink = [CADisplayLink displayLinkWithTarget:self selector:@selector(handleDisplayLink:)]; // 每隔1帧调用一次self.displayLink.frameInterval = 1; [self.displayLink addToRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; 释放方法： 1234567891011121314151617181920212223242526272829303132333435363738394041[self.displayLink invalidate]; self.displayLink = nil;``` 当把**CADisplayLink**对象添加到runloop中后，`selector`就能被周期性调用，类似于重复的NSTimer被启动了；执行`invalidate`操作时，CADisplayLink对象就会从runloop中移除，`selector`调用也随即停止，类似于NSTimer的`invalidate`方法。**CADisplayLink**中有两个重要的属性：- **frameInterval** NSInteger类型的值，用来设置间隔多少帧调用一次`selector`方法，默认值是1，即每帧都调用一次。 - **duration** `CFTimeInterval`值为`readOnly`，表示两次屏幕刷新之间的时间间隔。需要注意的是，该属性在`targe`t的`selector`被首次调用以后才会被赋值。`selector`的调用间隔时间计算方式是：**调用间隔时间 = duration × frameInterval**。 ###特点- **刷新频率固定** 正常情况iOS设备的屏幕刷新频率是固定**60Hz**,如果CPU过于繁忙，无法保证屏幕60次/秒的刷新率，就会导致跳过若干次调用回调方法的机会，跳过次数取决CPU的忙碌程度。- **屏幕刷新时调用** CADisplayLink在正常情况下会在每次刷新结束都被调用，精确度相当高。但如果调用的方法比较耗时，超过了屏幕刷新周期，就会导致跳过若干次回调调用机会 - **适合做界面渲染** CADisplayLink可以确保系统渲染每一帧的时候我们的方法都被调用，从而保证了动画的流畅性。##GCD定时器**GCD定时器**和NSTimer是不一样的，NSTimer受RunLoop影响，但是GCD的定时器不受影响，因为通过源码可知RunLoop也是基于GCD的实现的，所以GCD定时器有非常高的精度。关于GCD的使用可一看看[这篇博客](http://www.cnblogs.com/pure/archive/2013/03/31/2977420.html)。###使用方法创建GCD定时器定时器的方法稍微比较复杂，看下面的代码：####单次的延时调用NSObject中的`performSelector:withObject:afterDelay:`以及 `performSelector:withObject:afterDelay:inModes:` 这两个方法在调用的时候会设置当前 runloop 中 `timer` ，前者设置的 `timer` 在 `NSDefaultRunLoopMode` 运行，后者则可以指定 **NSRunLoop** 的 `mode` 来执行。我们上面介绍过 runloop 中 `timer` 在 `UITrackingRunLoopMode` 被挂起，就导致了代码就会一直等待 `timer` 的调度,解决办法在上面也有说明。不过我们可以用另一套方案来解决这个问题，就是使用GCD中的 `dispatch_after` 来实现单次的延时调用： double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC)); dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ [self someMethod]; });12####循环调用 // 创建GCD定时器dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0); //每秒执行 // 事件回调dispatch_source_set_event_handler(_timer, ^{ dispatch_async(dispatch_get_main_queue(), ^{ // 在主线程中实现需要的功能 } } }); // 开启定时器dispatch_resume(_timer); // 挂起定时器（dispatch_suspend 之后的 Timer，是不能被释放的！会引起崩溃）dispatch_suspend(_timer); // 关闭定时器dispatch_source_cancel(_timer); 12345678910111213141516171819上面代码中要注意的是：1. `dispatch_source_set_event_handler()`中的任务实在子线程中执行的，若需要回到主线程，要调用`dispatch_async(dispatch_get_main_queue(), ^&#123;&#125;`.- `dispatch_source_set_timer` 中第二个参数，当我们使用 `dispatch_time` 或者 `DISPATCH_TIME_NOW` 时，系统会使用默认时钟来进行计时。然而当系统休眠的时候，默认时钟是不走的，也就会导致计时器停止。使用 `dispatch_walltime ` 可以让计时器按照真实时间间隔进行计时.- 第三个参数， ` 1.0 * NSEC_PER_SEC` 为每秒执行一次，对应的还有毫秒，分秒，纳秒可以选择.- `dispatch_source_set_event_handler` 这个函数在执行完之后，block 会立马执行一遍，后面隔一定时间间隔再执行一次。而 `NSTimer` 第一次执行是到计时器触发之后。这也是和 `NSTimer` 之间的一个显著区别。- 挂起（暂停）定时器, `dispatch_suspend` 之后的 `Timer`，不能被释放的,会引起崩溃.- 创建的`timer`一定要有`dispatch_suspend(_timer)`或`dispatch_source_cancel(_timer)`这两句话来指定出口，否则定时器将不执行，若我们想无限循环可将 `dispatch_source_cancel(_timer)` 写在一句永不执行的`if`判断语句中。##使用场景介绍完iOS中的各种定时器，接下来我们来说说这几种定时器在开发中的几种用法。###短信重发倒计时短信倒计时使我们登录注册常用的功能，一般设置为60s，实现方法如下： // 计时时间@property (nonatomic, assign) int timeout; /* 开启倒计时 / (void)startCountdown { if (_timeout &gt; 0) { return; } _timeout = 60; // GCD定时器 dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0); //每秒执行 dispatch_source_set_event_handler(_timer, ^{ if(_timeout &lt;= 0 ){// 倒计时结束 // 关闭定时器 dispatch_source_cancel(_timer); dispatch_async(dispatch_get_main_queue(), ^{ //设置界面的按钮显示 根据自己需求设置 [self.sendMsgBtn setTitle:@&quot;发送&quot; forState:UIControlStateNormal]; self.sendMsgBtn.enabled = YES; }); }else{// 倒计时中 // 显示倒计时结果 NSString *strTime = [NSString stringWithFormat:@&quot;重发(%.2d)&quot;, _timeout]; dispatch_async(dispatch_get_main_queue(), ^{ //设置界面的按钮显示 根据自己需求设置 [self.sendMsgBtn setTitle:[NSString stringWithFormat:@&quot;%@&quot;,strTime] forState:UIControlStateNormal]; self.sendMsgBtn.enabled = NO; }); _timeout--; } }); // 开启定时器 dispatch_resume(_timer); }123456789101112131415161718192021222324在上面代码中，我们设置了一个60s循环倒计时，当我们向服务器获取短信验证码成功时 调用该方法开始倒计时。每秒刷新按钮的倒计时数，倒计时结束时再将按钮 `Title` 恢复为“发送”.有一点需要注意的是，按钮的样式要设置为 **UIButtonTypeCustom**,否则会出现刷新 `Title` 时闪烁.我们可以把这个方法封装一下，方便调用，否则在控制器中写这么一大段代码确实也不优雅。效果如下：![](http://upload-images.jianshu.io/upload_images/2178672-3d4d1353bcc36026.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)##### [代码链接](https://github.com/qiubaiying/BYTimer)###每个几分钟向服务器发送数据在有定位服务的APP中，我们需要每个一段时间将定位数据发送到服务器，比如每5s定位一次每隔5分钟将再统一将数据发送服务器，这样会处理比较省电。一般程序进入后台时，定时器会停止，但是在定位APP中，需要持续进行定位，APP在后台时依旧可以运行，所以在后台定时器也是可以运行的。注：关于iOS后台常驻,可以查看[这篇博客](http://waitingyuan.blog.163.com/blog/static/2155781652014111133150534/)在使用GCD定时的时候发现GCD定时器也可以在后代运行，创建方法同上面的短信倒计时.这里我们使用**NSTimer**来创建一个每个5分钟执行一次的定时器. #import &lt;Foundation/Foundation.h&gt; typedef void(^TimerBlock)(); @interface BYTimer : NSObject (void)startTimerWithBlock:(TimerBlock)timerBlock; (void)stopTimer; @end 12 #import “BYTimer.h” @interface BYTimer () @property (nonatomic, strong) NSTimer *timer;@property (nonatomic, strong) TimerBlock timerBlock; @end @implementation BYTimer (void)startTimerWithBlock:(TimerBlock)timerBlock { self.timer = [NSTimer timerWithTimeInterval:300 target:self selector:@selector(_timerAction) userInfo:nil repeats:YES]; [[NSRunLoop mainRunLoop] addTimer:self.timer forMode:NSRunLoopCommonModes]; _timerBlock = timerBlock; } (void)_timerAction { if (self.timerBlock) { self.timerBlock(); }} (void)stopTimer { [self.timer invalidate];} @end` 该接口的实现很简单，就是 NSTimer 创建了一个300s执行一次的定时器，但是要注意定时器需要加入NSRunLoopCommonModes中。 要使定时器在后台能运行，app 就需要在 后台常驻。 结语最后总结一下： NSTimer 使用简单方便，但是应用条件有限。 CADisplayLink 刷新频率与屏幕帧数相同，用于绘制动画。具体使用可看我封装好的一个 水波纹动画。 GCD定时器 精度高，可控性强，使用稍复杂。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快速添加圆角和描边]]></title>
    <url>%2F2016%2F12%2F01%2F%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E5%9C%86%E8%A7%92%E5%92%8C%E6%8F%8F%E8%BE%B9%2F</url>
    <content type="text"><![CDATA[前言对于习惯使用Storyboard的人来说，设置圆角、描边是一件比较蛋疼的事，因为苹果没有在xcode的Interface Builder上直接提供修改控件的圆角，边框设置。 我们来说说如何对某个控件进行圆角、描边处理： 初级对于一个初学者来说，如果要进行某个控件的圆角、描边设置，就要从Storyboard关联出属性，然后再对属性进行代码处理。 如下代码： 1234self.myButton.layer.cornerRadius = 20;self.myButton.layer.masksToBounds = YES;self.myButton.layer.borderWidth = 2;self.myButton.layer.borderColor = [UIColor blackColor].CGColor; 这样不仅需要Storyboard关联出属性，还要写一堆代码对属性进行设置，不得不说实在麻烦~ 中级更聪明的做法是使用Storyboard提供的Runtime Attributes为控件添加圆角描边。 选中控件，然后在Runtime Attributes框中输入对应的Key与Type与Value,这样程序在运行时就会通过KVC为你的控件属性进行赋值。(不仅仅是圆角、描边~) 如下图 设置圆角、描边的Key为： 1234layer.borderWidthlayer.borderColorFromUIColorlayer.cornerRadiusclipsToBounds 我这次在测试时， 这样做不用关联出属性，但是需要输入大串字符串，也是不够方便。 高级创建UIView的分类，使用IBInspectable+ IB_DESIGNABLE关键字： 1234567891011#import &lt;UIKit/UIKit.h&gt;IB_DESIGNABLE@interface UIView (Inspectable)@property(nonatomic,assign) IBInspectable CGFloat cornerRadius;@property(nonatomic,assign) IBInspectable CGFloat borderWidth;@property(nonatomic,assign) IBInspectable UIColor *borderColor;@end 1234567891011121314151617181920212223242526#import &quot;UIView+Inspectable.h&quot;@implementation UIView (Inspectable)-(void)setCornerRadius:(CGFloat)cornerRadius&#123; self.layer.masksToBounds = YES; self.layer.cornerRadius = cornerRadius;&#125;-(void)setBorderColor:(UIColor *)borderColor&#123; self.layer.borderColor = borderColor.CGColor;&#125;-(void)setBorderWidth:(CGFloat)borderWidth&#123; self.layer.borderWidth = borderWidth;&#125;- (CGFloat)cornerRadius&#123; return self.layer.cornerRadius;&#125;- (CGFloat)borderWidth&#123; return self.layer.borderWidth;&#125;- (UIColor *)borderColor&#123; return [UIColor colorWithCGColor:self.layer.borderColor];&#125;@end 附上：GitHub地址 直接使用直接将这两个文件拖入项目中即可使用，在右边栏将会显示圆角和描边的属性设置 如图： 动态显示设置效果直接使用的话只有在运行时才能看到效果， 例如要实时显示一个UIBUtton圆角、描边效果，需要创建一个类继承UIButton 123456#import &lt;UIKit/UIKit.h&gt;#import &quot;UIView+Inspectable.h&quot;@interface myButton : UIButton@end 12345#import &quot;myButton.h&quot;@implementation myButton@end 只要将button的Class选择该空白类即可 关于IBInspectable与IB_DESIGNABLE的使用详情可以参考这篇文章《谈不完美的IBDesignable/IBInspectable可视化效果编程》]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSON转模型 For YYModel]]></title>
    <url>%2F2016%2F10%2F26%2FJSON-%E8%BD%AC%E6%A8%A1%E5%9E%8B-For-YYModel%2F</url>
    <content type="text"><![CDATA[JSON转模型是我们做iOS开发的基础技能，本文将通过YYModel这个框架安全快速的完成JSON到模型的转换，其中还会介绍到一款好用的插件ESJsonFormat。 1、首先创建模型类创建模型类我们可以通过ESJsonFormat这款插件快速完成。 使用方法： 将光标移动到代码行中 如下图的13行 然后点击Window-&gt;ESJsonFormat-&gt;Input JSON Window调出窗口 在窗口中输入你要解析的JSON文本，如下图： 按Enter继续，然后神奇的一幕发生了 看到在.h中 所有的属性自动为你填上，而且帮你选好了类型 .m 也为你声明了list中成员的类型，不过这里需要稍作修改，因为我们需要用到YYModel进行解析，所以方法名改成modelContainerPropertyGenericClass 123+ (NSDictionary *)modelContainerPropertyGenericClass &#123; return @&#123;@&quot;list&quot; : [List class]&#125;;&#125; 还有问题就是属性中出现关键字id，我们需要将id改为teacherId 然后在.m的implementation中声明,将字典的的id 123+ (NSDictionary *)modelCustomPropertyMapper &#123; return @&#123;@&quot;teacherId&quot; : @&quot;id&quot;&#125;;&#125; 这样，模型的创建就完成了，剩下的就是用YYModel进行解析了 2、使用YYModel进行解析解析很简单，就只需要一句话 123456// 将 JSON (NSData,NSString,NSDictionary) 转换为 Model:Model *model = [Model yy_modelWithJSON:json];// 或者Model *model = [[Model alloc] init];[model yy_modelSetWithDictionary:json]; 到此，简便快速的完成了JSON到模型的转换。 最后，这里附上一篇YYModel的使用]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开发技巧</tag>
      </tags>
  </entry>
</search>
